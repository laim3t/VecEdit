### **任务简报：修复新架构的数据加载逻辑以显示向量数据**

**1. 任务目标 (The Goal)**

当前"高级向量表视图"(`AdvancedVectorDialog`)只能正确显示列标题，但无法显示任何数据行。

本次任务的目标是，**彻底重构 `VectorTableModel::loadRowData` 函数**，使其能够根据新的混合存储架构，正确地从二进制文件中加载行数据并将其显示在表格中。

**2. 核心架构与数据流 (The Architecture & Data Flow)**

你必须理解并遵循项目当前最新的数据存储架构：

*   **架构模式**: 混合存储模型。
    *   **SQLite 数据库**: 扮演 **元数据存储** 的角色。
        *   `VectorTableMasterRecord` 表：存储每个向量表的"主记录"，包含了最重要的信息：`binary_data_filename`（二进制数据文件的文件名）。
        *   `VectorTableColumnConfiguration` 表：存储每个向量表的详细列定义（列名、顺序、数据类型等）。
    *   **二进制文件 (`.vbindata`)**: 扮演 **实际数据存储** 的角色。所有的数据行都序列化后存储在这些文件中，数据库中不再有完整的行数据。

*   **正确的数据加载流程**:
    1.  `AdvancedVectorDialog` 请求 `VectorTableModel` 加载一个表 (通过 `tableId`)。
    2.  `VectorTableModel::loadTable` 被调用。
    3.  它调用 `loadColumnConfiguration`，此部分工作正常，已从 `VectorTableColumnConfiguration` 加载列结构。
    4.  它接着调用 `loadRowData`。**这是需要被重构的部分。**
    5.  `loadRowData` **必须** 先从 `VectorTableMasterRecord` 查询到二进制文件名，然后打开并解析该文件来获取所有行数据。

**3. 关键问题与重构指令 (The Problem & Refactoring Instructions)**

当前 `VectorTableModel::loadRowData` 的实现是 **完全错误** 的。它试图从旧的 `vector_table_data` SQL表中查询行数据，这与新架构完全不符，因此必须被彻底替换。

**请严格按照以下步骤重构 `loadRowData` 函数：**

**第一步：分析并复用现有二进制处理逻辑**

*   项目中已经存在用于处理二进制文件的帮助类：`database/binaryfilehelper.h` 和 `database/binaryfilehelper.cpp`。
*   **请务必先仔细阅读 `BinaryFileHelper` 的实现**。它很可能已经包含了写入二进制文件的逻辑。你需要做的是理解其文件格式（例如，它使用了 `QDataStream` 吗？它如何写入不同类型的数据？），然后在 `loadRowData` 中实现一个**逆向的读取操作**。

**第二步：重写 `VectorTableModel::loadRowData`**

*   **删除旧代码**: 将 `loadRowData` 函数内部的**所有代码完全删除**。所有关于 `hasVectorTableData`、`hasPinValues` 的检查以及所有 `QSqlQuery` 相关的代码都必须清除。
*   **实现新逻辑**:

    ```cpp
    bool VectorTableModel::loadRowData() {
        // 1. 清空旧数据
        beginResetModel(); // 通知视图即将发生重大变化
        m_rows.clear();
        endResetModel();

        if (m_tableId <= 0) return false;

        QSqlDatabase db = DatabaseManager::instance()->database();

        // 2. 从 VectorTableMasterRecord 获取二进制文件名
        QSqlQuery masterQuery(db);
        masterQuery.prepare("SELECT binary_data_filename FROM VectorTableMasterRecord WHERE id = ?");
        masterQuery.addBindValue(m_tableId);

        if (!masterQuery.exec() || !masterQuery.next()) {
            qWarning() << "Could not find binary data filename for master record ID:" << m_tableId;
            return false;
        }
        QString binaryFilename = masterQuery.value(0).toString();

        // 3. 构建文件的完整路径 (可能需要 PathUtils 或类似工具)
        // 假设数据库文件和二进制文件在同一目录
        QString dbPath = db.databaseName();
        QFileInfo dbInfo(dbPath);
        QString binaryFilePath = dbInfo.absolutePath() + "/" + binaryFilename;

        if (!QFile::exists(binaryFilePath)) {
            qWarning() << "Binary data file does not exist:" << binaryFilePath;
            return false; // 或者可以创建一个空文件
        }

        // 4. 使用 BinaryFileHelper 或直接用 QDataStream 读取文件
        //    (此处的具体实现取决于第一步中对 BinaryFileHelper 的分析)
        QFile file(binaryFilePath);
        if (!file.open(QIODevice::ReadOnly)) {
            qWarning() << "Failed to open binary file for reading:" << binaryFilePath;
            return false;
        }

        QDataStream stream(&file);
        // 设置与写入时匹配的版本
        stream.setVersion(QDataStream::Qt_5_15); 
        
        QList<Vector::RowData> allRows;
        
        // 循环读取，直到文件末尾
        while (!stream.atEnd()) {
            Vector::RowData newRow;
            // 遍历已加载的列配置 (m_columns)
            for (const auto& column : m_columns) {
                QVariant cellData;
                // 根据 column.type 从流中读取相应类型的数据
                // 这是实现的核心，必须与写入逻辑完全对应
                // 例如:
                // if (column.type == "TEXT") { QString val; stream >> val; cellData = val; }
                // else if (column.type == "INTEGER") { qint32 val; stream >> val; cellData = val; }
                // ... etc. for all types defined in VectorTableColumnConfiguration
                
                // 你需要根据 BinaryFileHelper 的写入逻辑来填充这里
                
                newRow.append(cellData);
            }
            allRows.append(newRow);
        }
        file.close();

        // 5. 将读取到的数据加载到模型中
        if (!allRows.isEmpty()) {
            beginInsertRows(QModelIndex(), 0, allRows.count() - 1);
            m_rows = allRows;
            endInsertRows();
        }

        qDebug() << "Successfully loaded" << m_rows.count() << "rows from" << binaryFilename;
        return true;
    }
    ```

**4. 代码上下文 (Code Context)**

为帮助你更好地完成任务，请务必参考以下文件的当前实现：

*   **`database/binaryfilehelper.h` 和 `database/binaryfilehelper.cpp` (最关键的参考！)**
*   `vector/vectortablemodel.h` 和 `vector/vectortablemodel.cpp` (需要修改的文件)
*   `resources/db/schema.sql` (用于理解数据库表结构)
*   `vector/vector_data_types.h` (查看 `Vector::RowData` 等类型的定义) 