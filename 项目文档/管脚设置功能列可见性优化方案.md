# 管脚设置功能列可见性优化方案

## 一、方案概述

### 1.1 问题背景

在当前的向量表管脚设置功能中，每当用户添加或移除管脚（列）时，系统需要对二进制数据文件进行大规模重构，这会导致严重的性能问题，特别是在处理百万级数据时，操作可能需要数分钟才能完成，严重影响用户体验。

### 1.2 解决思路

本方案采用**"预分配固定管脚列 + 可见性控制"**策略，通过在创建向量表时预先分配固定数量的管脚列（默认不可见），然后利用数据库中的可见性标志来控制列的显示与隐藏，从而避免二进制文件的频繁重构。

### 1.3 核心理念

- **物理结构固定**：向量表创建后，二进制文件的物理结构（行大小和格式）保持不变
- **逻辑结构灵活**：通过数据库中的可见性标志控制列的显示与隐藏
- **零数据迁移**：添加或删除管脚列时，无需修改二进制文件，只需更新数据库标志

## 二、技术实现详解

### 2.1 预分配管脚列

在创建新的向量表时，系统会预先分配3个管脚列，这些列在物理上存在于二进制文件中，但在逻辑上默认为不可见状态：

```sql
-- 创建向量表时，预分配3个管脚列
INSERT INTO VectorTableColumnConfiguration 
(master_record_id, column_name, column_order, column_type, IsVisible) 
VALUES 
(new_table_id, 'PIN_A', 5, 'PIN_STATE_ID', 0),
(new_table_id, 'PIN_B', 6, 'PIN_STATE_ID', 0),
(new_table_id, 'PIN_C', 7, 'PIN_STATE_ID', 0);
```

### 2.2 可见性控制机制

管脚列的添加和删除通过修改 `VectorTableColumnConfiguration` 表中的 `IsVisible` 字段实现：

```sql
-- "添加"管脚列（将预分配的列标记为可见）
UPDATE VectorTableColumnConfiguration 
SET IsVisible = 1, column_name = '新管脚名' 
WHERE master_record_id = :tableId AND column_order = :unusedColumnOrder;

-- "删除"管脚列（将列标记为不可见）
UPDATE VectorTableColumnConfiguration 
SET IsVisible = 0
WHERE master_record_id = :tableId AND column_name = :columnName;
```

### 2.3 数据加载与显示

`RobustVectorDataHandler` 在加载数据时，会根据 `IsVisible` 字段过滤列：

```cpp
bool RobustVectorDataHandler::loadVectorTableMeta(int tableId, QString &binFileName, 
                                                 QList<Vector::ColumnInfo> &columns,
                                                 int &rowCount, int &schemaVersion)
{
    // ... 现有代码 ...
    
    // 只加载可见的列
    query.prepare("SELECT id, column_name, column_order, column_type FROM VectorTableColumnConfiguration "
                 "WHERE master_record_id = ? AND IsVisible = 1 ORDER BY column_order");
    query.addBindValue(tableId);
    
    // ... 后续代码 ...
}
```

### 2.4 数据写入与默认值处理

当用户修改新显示的管脚列值时，系统会将这些值写入到预分配的物理列中：

```cpp
bool RobustVectorDataHandler::updateVectorCellValue(int tableId, int rowIndex, 
                                                   const QString &columnName, 
                                                   const QVariant &newValue)
{
    // 获取列的物理位置
    int physicalColumnOrder = getPhysicalColumnOrder(tableId, columnName);
    
    // 更新二进制文件中对应位置的值
    return BinaryFileHelper::updateCellValue(
        resolveBinaryFilePath(tableId),
        rowIndex,
        physicalColumnOrder,
        newValue
    );
}
```

## 三、方案优势分析

### 3.1 性能优势

1. **极速响应**：添加/删除管脚列操作只涉及数据库标志位的修改，可在毫秒级完成
2. **零数据迁移**：无需重建二进制文件，彻底避免了大数据量下的性能瓶颈
3. **内存效率**：只加载可见列的数据，减少内存占用

### 3.2 数据一致性保障

1. **数据持久性**：即使管脚列被"删除"，其数据仍物理保存在文件中
2. **恢复能力**：可以随时恢复之前"删除"的管脚列，并保留其原始数据
3. **操作安全性**：避免了文件重写过程中可能出现的数据损坏风险

### 3.3 用户体验提升

1. **即时响应**：用户添加/删除管脚列的操作可以立即生效，无需等待
2. **一致的性能**：无论数据量大小，操作响应时间保持稳定
3. **可靠性提升**：减少了因长时间操作被中断导致的数据不一致风险

## 四、实施步骤

### 4.1 修改表创建逻辑

更新 `RobustVectorDataHandler::createVectorTable` 方法，在创建表时预分配3个管脚列：

```cpp
bool RobustVectorDataHandler::createVectorTable(const QString &tableName, const QList<Vector::ColumnInfo> &baseColumns)
{
    // ... 现有代码 ...
    
    // 添加基础列
    for (int i = 0; i < baseColumns.size(); ++i) {
        // ... 插入基础列 ...
    }
    
    // 添加3个预分配的管脚列（默认不可见）
    query.prepare("INSERT INTO VectorTableColumnConfiguration "
                 "(master_record_id, column_name, column_order, column_type, IsVisible) "
                 "VALUES (?, ?, ?, ?, 0)");
    
    for (int i = 0; i < 3; ++i) {
        query.addBindValue(tableId);
        query.addBindValue(QString("PIN_%1").arg(QChar('A' + i)));
        query.addBindValue(baseColumns.size() + i);
        query.addBindValue("PIN_STATE_ID");
        if (!query.exec()) {
            // ... 错误处理 ...
        }
    }
    
    // ... 后续代码 ...
}
```

### 4.2 实现管脚列显示/隐藏功能

添加两个新方法到 `RobustVectorDataHandler` 类：

```cpp
bool RobustVectorDataHandler::showVectorTableColumn(int tableId, const QString &columnName)
{
    QSqlQuery query;
    query.prepare("UPDATE VectorTableColumnConfiguration SET IsVisible = 1 "
                 "WHERE master_record_id = ? AND column_name = ?");
    query.addBindValue(tableId);
    query.addBindValue(columnName);
    return query.exec();
}

bool RobustVectorDataHandler::hideVectorTableColumn(int tableId, const QString &columnName)
{
    QSqlQuery query;
    query.prepare("UPDATE VectorTableColumnConfiguration SET IsVisible = 0 "
                 "WHERE master_record_id = ? AND column_name = ?");
    query.addBindValue(tableId);
    query.addBindValue(columnName);
    return query.exec();
}
```

### 4.3 更新管脚设置对话框

修改 `VectorPinSettingsDialog` 类，使其利用新的显示/隐藏机制：

```cpp
void VectorPinSettingsDialog::onAddPinClicked()
{
    // ... 获取用户选择的管脚 ...
    
    // 查找一个未使用的预分配列
    QSqlQuery query;
    query.prepare("SELECT column_name FROM VectorTableColumnConfiguration "
                 "WHERE master_record_id = ? AND IsVisible = 0 AND "
                 "column_type = 'PIN_STATE_ID' LIMIT 1");
    query.addBindValue(m_tableId);
    
    if (query.exec() && query.next()) {
        QString unusedColumn = query.value(0).toString();
        
        // 更新列名称并设置为可见
        query.prepare("UPDATE VectorTableColumnConfiguration "
                     "SET column_name = ?, IsVisible = 1 "
                     "WHERE master_record_id = ? AND column_name = ?");
        query.addBindValue(selectedPin);
        query.addBindValue(m_tableId);
        query.addBindValue(unusedColumn);
        
        if (query.exec()) {
            // 通知模型刷新
            emit pinConfigurationChanged();
        }
    } else {
        QMessageBox::warning(this, "添加失败", "已达到预分配管脚列的上限（3个）");
    }
}

void VectorPinSettingsDialog::onRemovePinClicked()
{
    // ... 获取用户选择的管脚 ...
    
    // 将列设置为不可见
    QSqlQuery query;
    query.prepare("UPDATE VectorTableColumnConfiguration "
                 "SET IsVisible = 0 "
                 "WHERE master_record_id = ? AND column_name = ?");
    query.addBindValue(m_tableId);
    query.addBindValue(selectedPin);
    
    if (query.exec()) {
        // 通知模型刷新
        emit pinConfigurationChanged();
    }
}
```

## 五、限制与扩展

### 5.1 已知限制

1. **管脚数量上限**：当前方案限制每个向量表最多只能同时显示3个管脚列
2. **存储空间利用**：即使不使用所有预分配列，也会占用存储空间
3. **列顺序固定**：预分配的列顺序是固定的，无法动态调整

### 5.2 未来扩展方向

1. **动态预分配**：根据项目历史使用情况，自动调整预分配的管脚列数量
2. **垃圾回收机制**：定期执行优化操作，清理长期不用的预分配列数据
3. **高级列管理**：实现列重排序功能，允许用户调整管脚列的显示顺序

## 六、结论

"预分配固定管脚列 + 可见性控制"方案通过巧妙地利用现有架构，实现了管脚列添加/删除操作的毫秒级响应，彻底解决了大数据量下的性能瓶颈问题。该方案在保持高性能的同时，还确保了数据的完整性和可恢复性，为用户提供了流畅、可靠的操作体验。

虽然当前实现限制了同时可见的管脚列数量，但这个限制在实际使用中很少成为问题，因为大多数用户同时只需要查看少量的管脚列。未来，我们可以根据实际需求，进一步优化和扩展这一机制，以支持更复杂的使用场景。
