# 向量表列可见性架构切换建议

**文档目的**：本文档旨在详细阐述在“每个向量表最多只有3列管脚列”的新约束下，将当前的数据列可见性控制方案从**“数据层过滤”**切换为**“视图层隐藏”**的技术建议。我们强烈推荐进行此项架构优化，以获得显著的性能提升、代码简化和系统健壮性增强。

---

## 1. 摘要

当前系统为了支持海量数据和大量管脚列，采用了在**数据层（`RobustVectorDataHandler`）**进行数据过滤的复杂架构。然而，随着业务需求明确为“最多3列管脚”，这一设计的复杂度已远超实际需求，成为了性能瓶颈和潜在Bug的来源（例如我们刚刚修复的数据错位问题）。

本文提出的**“视图层隐藏”方案**，是行业标准且更符合当前场景的架构。它主张由数据层提供完整数据，由模型层持有完整数据，而列的显示/隐藏则完全交由**视图层（`QTableView`）**在内存中瞬时完成。

采纳此方案，将带来以下核心收益：
- **极致的性能体验**：显示/隐藏列的操作将从磁盘I/O转为纯内存操作，响应时间从秒级提升至毫秒级。
- **代码逻辑极大简化**：`RobustVectorDataHandler`中复杂的映射和合并逻辑将被彻底移除，代码更易于维护。
- **系统健壮性根本性提升**：彻底杜绝因数据与视图列数不匹配导致的数据错位、损坏等一系列问题。

---

## 2. 两种架构的深度对比

### 方案A: “数据层过滤”架构（当前实现）

- **工作原理**:
    1. `VectorTableModel`（模型）向 `RobustVectorDataHandler`（数据层）请求数据。
    2. `RobustVectorDataHandler` 从数据库获取**可见列**的定义。
    3. 从二进制文件中读取出**完整的行数据**。
    4. **在数据层内部进行过滤**，只将可见列的数据返回给模型。
    5. 当需要保存数据时，模型层只传来可见列的数据，数据层需要**先读取旧的完整行，再将新数据合并进去**，最后写回。

- **优点**:
    - **内存占用极低**：这是其设计的初衷，在有几十上百个管脚列时，只在内存中加载可见列，优势明显。

- **缺点**:
    - **性能瓶颈**：每次显示/隐藏列，都必须重新从硬盘读取和过滤全部数据，对于UI操作来说响应太慢。
    - **逻辑极其复杂**：数据层需要维护两套数据结构（完整的物理行和可见的逻辑行），并负责它们之间的双向映射。这导致代码难以理解和维护。
    - **高风险**：复杂的映射逻辑是数据错位、不一致等严重Bug的温床。我们刚刚修复的问题就是最好的例子。
    - **过度设计**：对于“最多3列”的场景，这种为了节省微不足道的内存而引入的复杂性，是典型的过度设计。

### 方案B: “视图层隐藏”架构（推荐方案）

- **工作原理**:
    1. `VectorTableModel`（模型）向 `RobustVectorDataHandler`（数据层）请求数据。
    2. `RobustVectorDataHandler` **总是**从二进制文件读取并返回**完整的行数据**（包含所有物理列，无论可见与否）。
    3. `VectorTableModel` **总是**在内存中持有完整的、与物理存储完全一致的数据。
    4. `MainWindow`（或相关UI控制器）根据用户的设置，调用 `QTableView->setColumnHidden(columnIndex, true)` 直接在视图层面控制列的显示和隐藏。

- **优点**:
    - **极致性能，瞬时响应**：显示/隐藏列是纯内存操作，`QTableView`只是改变了渲染方式，速度极快，用户体验极佳。
    - **逻辑极度简化**：`RobustVectorDataHandler` 的职责变得纯粹，它不再关心“可见性”，只需负责读写完整的行数据。所有复杂的映射、过滤、合并逻辑全部消失。
    - **代码健壮，易于维护**：数据模型与物理存储永远保持一致，彻底消除了数据错位的可能性。代码更少，Bug也更少。
    - **符合Qt标准实践**：这是经典的MVC（模型-视图-控制器）模式的最佳实践，职责划分清晰。

- **缺点 (在当前约束下已不成问题)**:
    - **内存占用稍高**：模型会多加载1-2列隐藏的数据。但在“最多3列”的约束下，这点内存开销（对于百万行数据可能也只是几MB到几十MB）与获得的巨大收益相比，完全可以忽略不计。

---

## 3. 架构切换实施步骤

切换到“视图层隐藏”方案是可行的，且改动范围相对集中。

### 步骤一：简化 `RobustVectorDataHandler`

这是核心改动。目标是让它变得“无知”，不再处理可见性。

1.  **修改 `getAllVectorRows` (或类似的数据读取函数)**:
    *   移除所有与“可见列”相关的过滤逻辑。
    *   `loadVectorTableMeta` 函数应加载**所有**列的定义，而不仅仅是可见列。
    -   函数最终应总是返回包含**所有物理列**的完整数据 `QList<QList<QVariant>>`。

2.  **修改 `batchUpdateVectorRows` / `insertVectorRows` (或类似的数据写入函数)**:
    *   移除所有将“可见列数据”合并到“完整行数据”的复杂逻辑。
    *   这两个函数现在可以假定，从模型层传递过来的数据已经是包含所有物理列的完整数据。

### 步骤二：调整 `VectorTableModel`

1.  **确保持有完整数据**:
    *   修改 `loadAllData` 等函数，确保模型从 `RobustVectorDataHandler` 获取并存储的是完整的行数据。
    *   `columnCount()` 方法现在应该返回**总的物理列数**，而不是可见列数。
    *   `headerData()` 方法需要能为所有物理列（包括当前隐藏的）提供正确的表头信息。

### 步骤三：修改UI控制逻辑 (`MainWindow` 和 `VectorPinSettingsDialog`)

这是实现新行为的关键。

1.  **`VectorPinSettingsDialog` 的职责变更**:
    *   当用户在“设置向量表”对话框点击“确定”后，此对话框的`onAccepted()`方法**不再**触发`MainWindow::reloadAndRefreshVectorTable`。
    *   它的新职责是：
        a. 将用户选择的可见性配置更新到数据库（为了下次打开程序时记住状态）。
        b. 发出一个信号，例如 `visibilityChanged(const QMap<QString, bool>& columnVisibility)`，将最新的列可见性状态传递出去。

2.  **`MainWindow` 的新槽函数**:
    *   在`MainWindow`中创建一个新的槽函数，例如 `onColumnVisibilityChanged(const QMap<QString, bool>& columnVisibility)`，并将其连接到 `VectorPinSettingsDialog` 发出的信号。
    *   此槽函数的实现如下：
        ```cpp
        void MainWindow::onColumnVisibilityChanged(const QMap<QString, bool>& columnVisibility)
        {
            // 假设 m_vectorTableModel 已经持有所有列
            // 我们需要一个方法来从列名映射到模型中的物理列索引
            for (auto it = columnVisibility.constBegin(); it != columnVisibility.constEnd(); ++it)
            {
                const QString& columnName = it.key();
                bool isVisible = it.value();
                
                int physicalIndex = m_vectorTableModel->findColumn(columnName); 
                if (physicalIndex != -1)
                {
                    // 核心操作：直接在视图上显示/隐藏列
                    ui->vectorTableView->setColumnHidden(physicalIndex, !isVisible);
                }
            }
        }
        ```

---

## 4. 结论

在“最多3列管脚”的明确约束下，继续维持为支持海量列而设计的“数据层过滤”架构，是不明智的。它不仅导致了糟糕的UI性能，还引入了不必要的复杂度和稳定性风险。

切换到**“视图层隐藏”**架构，是一次技术上的“拨乱反正”。它将用可忽略不计的内存开销，换来**性能的飞跃、代码的简化和系统的长期稳定**。我们强烈建议尽快规划并实施此项重构，这将是提升产品质量和开发效率的关键一步。 