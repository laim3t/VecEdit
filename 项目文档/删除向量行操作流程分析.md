# “新轨道”架构下删除向量行操作的详细流程分析

本文档基于对项目源代码的深入分析，详细阐述了在“新轨道”混合存储架构下，“删除向量行”这一核心操作从用户界面到数据持久层的完整实现流程。

**核心思想：逻辑删除 (Soft Delete)**

与传统方式不同，本项目中的删除操作极其高效。其核心在于采用了“逻辑删除”策略：**整个过程完全不触及和修改庞大的二进制数据文件 (`.vbindata`)，仅对SQLite数据库中的索引进行标记**。这避免了成本高昂的文件I/O和数据重整，使得删除百万行中的任意数据都能在毫秒级完成。

---

## 完整执行流程

整个流程遵循一个清晰的职责链：**UI -> Model -> Handler -> Database -> Model -> UI**。

### 1. 用户操作 (UI层)

-   **入口**: 用户在主界面的`QTableView`中选中一行或多行，点击工具栏上的“删除向量行”(`deleteSelectedVectorRows`)或“删除范围”(`deleteVectorRowsInRange`)按钮。
-   **信号触发**: 这会触发`MainWindow`中对应的槽函数，开始删除流程。此连接在 `MainWindow::setupToolBar` 中设置。

### 2. 请求传递 (`MainWindow` -> `VectorTableModel`)

-   **职责**: `MainWindow`作为控制器，负责响应用户交互。
-   **动作**:
    1.  从`QTableView`的`selectionModel()`中获取用户选中的行索引。
    2.  弹出一个`QMessageBox`进行二次确认，防止误操作。
    3.  确认后，调用`VectorTableModel`（数据模型）的接口，将删除请求（要删除的行号列表）传递给模型层。
    ```cpp
    // in MainWindow::deleteSelectedVectorRows
    m_vectorTableModel->deleteSelectedRows(absoluteRows, errorMessage);
    ```

### 3. 请求转发 (`VectorTableModel` -> `RobustVectorDataHandler`)

-   **职责**: `VectorTableModel`作为Qt的Model/View架构中的模型，负责管理数据并作为视图与后端逻辑的桥梁。
-   **动作**:
    1.  接收到来自`MainWindow`的删除请求。
    2.  它并不直接执行删除，而是将请求转发给专门负责数据持久化的后端核心处理器：`RobustVectorDataHandler`。
    ```cpp
    // in VectorTableModel::deleteSelectedRows
    m_robustDataHandler->deleteVectorRows(m_tableId, absoluteRowIndexes, errorMessage);
    ```

### 4. 核心逻辑：执行逻辑删除 (`RobustVectorDataHandler`)

-   **职责**: `RobustVectorDataHandler`是数据持久化的核心，直接与SQLite数据库交互，执行所有增删改查的底层逻辑。这是整个删除操作的“心脏”。
-   **动作**:
    1.  **开启数据库事务**: 调用`db.transaction()`。这确保了后续所有数据库操作的原子性，要么全部成功，要么全部失败回滚，保证了数据的一致性。
    2.  **标记索引为无效**: 这是逻辑删除的关键。执行一条`UPDATE` SQL语句，在`VectorTableRowIndex`索引表中，将指定行的`is_active`标志位从`1`更新为`0`。
        ```sql
        -- SQL in deleteVectorRows
        UPDATE VectorTableRowIndex SET is_active = 0
        WHERE master_record_id = ? AND logical_row_order = ?;
        ```
    3.  **更新总行数**: 为了让程序其他部分能正确获取当前表的总行数，接着会执行第二条`UPDATE`语句，在`VectorTableMasterRecord`主记录表中，将`row_count`字段减去本次删除的行数。
        ```sql
        -- SQL in deleteVectorRows
        UPDATE VectorTableMasterRecord SET row_count = row_count - ? WHERE id = ?;
        ```
    4.  **提交事务**: 若以上操作全部成功，则调用`db.commit()`，将所有更改写入数据库。若中途失败，则`catch`异常并调用`db.rollback()`，撤销所有操作。

    > **关键点**：在此阶段，程序**没有对`.vbindata`二进制文件进行任何读写操作**。物理数据被完整地保留，但由于其索引已被标记为无效，它们在逻辑上已对程序“不可见”，成为了待“垃圾回收”的数据。

### 5. 数据刷新 (`VectorTableModel`)

-   **职责**: 在后端数据成功更新后，模型需要同步这些变化。
-   **动作**:
    1.  `RobustVectorDataHandler`成功返回`true`后，`VectorTableModel`会立即调用自身的`loadAllData(m_tableId)`方法来刷新内部数据。
    2.  `loadAllData`会再次请求`RobustVectorDataHandler`从数据库获取所有行数据。此时，`RobustVectorDataHandler`的查询逻辑会默认包含`WHERE is_active = 1`的条件，因此只会加载回有效的行。
    3.  获取到最新的数据后，`VectorTableModel`会发出`beginResetModel()`和`endResetModel()`信号。

### 6. 界面更新 (UI层)

-   **职责**: `QTableView`响应模型的变化。
-   **动作**: `QTableView`接收到`VectorTableModel`发出的`modelReset`信号后，它会知道数据已发生根本性变化。于是，它会清空现有显示，并从`VectorTableModel`中重新拉取全部数据进行渲染。

至此，用户在界面上便看到了行被成功删除的最终效果。整个流程设计精妙，通过牺牲少量磁盘空间（已删除的“垃圾”数据），换取了极致的删除性能和操作的流畅性。 