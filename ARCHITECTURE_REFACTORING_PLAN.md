 # VecEdit 向量表架构演进与并行实施指南

本文档详细阐述 `VecEdit` 项目中向量表模块的架构升级计划。其核心目标是引入基于 Qt 模型/视图（Model/View）架构的`QTableView`，使其与现有的 `QTableWidget` 实现并行存在，互不干扰，为用户提供一个高性能的备选方案。

## 1. 核心思想：并行与共存

与传统的“迁移-替换”策略不同，本次重构遵循**并行与共存**的原则。我们不会废弃或移除当前基于 `QTableWidget` 的稳定实现。相反，我们将开发一套全新的、基于 `QTableView` 和自定义数据模型（`QAbstractTableModel`）的向量表系统。

**最终目标是实现两大架构的长期共存**：

*   **旧架构 (`QTableWidget`)**: 保持其现有功能，作为稳定、可靠的基础版本，其功能和稳定性不受任何影响。
*   **新架构 (`QTableView` + Model)**: 作为一个高性能、高可扩展性的高级选项，逐步实现并超越旧架构的所有功能。

这种策略确保了无论新架构的开发进度如何，项目始终拥有一个功能完整的核心版本，将重构风险降至最低，并为未来的功能扩展提供了强大的新平台。

## 2. 为何引入新架构？

`QTableWidget` 是一个便利的组件，但其将数据与视图紧密耦合的设计在面对大规模数据集时会暴露性能和维护性问题。引入模型/视图架构将带来以下关键优势：

- **极致性能**: `QTableView` 只处理当前可见的数据，能够以极低的内存占用流畅处理数十万甚至上百万行数据。
- **关注点分离**: 数据（Model）、展示（View）和逻辑（Controller/Delegate）分离，代码结构更清晰，更易于维护和测试。
- **强大的扩展性**: 可以轻松地添加排序、过滤（`QSortFilterProxyModel`）、自定义编辑委托（Delegate）等高级功能，而无需修改底层数据。
- **数据源解耦**: 数据模型可以独立于任何UI组件存在，它可以从数据库、文件或网络等任何来源获取数据，UI层无需关心具体实现。

## 3. 实施策略

我们将通过以下步骤，在不影响现有功能的前提下，渐进式地引入新架构：

1.  **创建独立入口**:
    - 在主窗口 `MainWindow` 的菜单栏中添加一个“**高级视图**”（或类似名称）的菜单项。
    - 点击该菜单项会弹出一个独立的、专门用于承载新架构的对话框或窗口。

2.  **构建数据模型 (`VectorTableModel`)**:
    - 这是新架构的基石。我们将创建一个继承自 `QAbstractTableModel` 的 `VectorTableModel` 类。
    - 该模型将直接与 `DatabaseManager` 通信，负责向量数据的获取、缓存、修改和持久化。它将成为新架构的“唯一数据源”。

3.  **开发新视图 (`VectorTableView`)**:
    - 在新窗口中，我们将放置一个 `QTableView` 实例，并将其与 `VectorTableModel` 实例进行绑定。
    - 所有与视图相关的展示逻辑，如行高、列宽、颜色等，将由 `QTableView` 及其委托（Delegate）管理。

4.  **功能并行实现**:
    - 我们将逐一在新架构中复现并优化旧架构的功能，例如：
        - 数据的正确加载与分页显示。
        - 单元格数据的编辑与验证。
        - 右键快捷菜单及其关联操作（如增删行、填充数据等）。
        - 排序与筛选功能。
    - 在整个开发过程中，旧的 `QTableWidget` 向量表功能将保持完全可用。

## 4. 架构隔离保证

为确保新旧架构互不干扰，我们将严格遵守以下原则：

- **UI 隔离**: 新旧两个向量表将存在于不同的窗口或Tab页中，拥有各自独立的UI控件和事件循环。
- **逻辑隔离**: 触发UI操作的槽函数（Slots）将是完全独立的。例如，新视图的右键菜单操作会连接到为新架构编写的专属槽函数上。
- **数据访问收敛**: 新旧架构都将通过 `DatabaseManager` 作为统一的数据持久化接口。这将保证数据的一致性，但数据在内存中的表示和管理方式（`QTableWidgetItem` vs. `VectorTableModel`）是完全隔离的。

通过以上设计，我们可以确保在引入一个功能强大、性能卓越的新架构的同时，保持现有系统的稳定性和完整性，为 `VecEdit` 的长远发展奠定坚实的基础。
