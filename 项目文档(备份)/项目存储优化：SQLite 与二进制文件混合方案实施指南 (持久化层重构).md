# 项目存储优化：SQLite 与二进制文件混合方案实施指南 (持久化层重构)

**重要前提：** 本方案的所有变更必须完全兼容当前系统。**禁止以任何形式修改任何已有的 UI 页面、控件、样式或用户交互逻辑。** 用户对现有界面和交互完全满意，任何可见的视觉或交互变动都将被视为重大缺陷。所有代码修改**只能限定在数据加载与存储的“持久化层”**，其他业务逻辑层（包括UI交互、数据校验、业务规则处理等）必须对此变更完全透明，即它们调用数据接口的方式和预期行为不发生改变。

本文档旨在指导您将当前项目的存储机制，从可能存在的纯 SQLite 存储大量行数据的方式，迁移到一种 SQLite 结合外部二进制文件的混合存储方案。目标是在**不改变任何用户可见行为的前提下**，显著优化大批量行数据的存储效率、减小项目文件体积，并提升读写性能。

## 1. 核心设计思路 (回顾)

我们将采用一种混合存储模型：

* **SQLite 数据库 (`.db` 文件)**：作为项目的主文件和“目录”。它将存储所有元数据、配置信息、查找表数据，以及最重要的——每个“向量表”的结构定义和指向其对应二进制数据文件的引用。**大量的实际行数据将不再存储于此。**
* **二进制数据文件 (例如 `.vbindata` 或自定义扩展名)**：每个用户在项目中创建的“向量表”（包含大量行数据）将对应一个独立的二进制文件。这些文件存储原始的、紧凑的行数据。其内部数据的结构由 SQLite 数据库中存储的相应元数据来定义。

这种分离可以让我们利用 SQLite 管理结构化元数据的便利性，同时享受二进制文件存储大块数据的性能和体积优势，而上层业务和UI代码对此无感知。

## 2. 实施步骤详解 (聚焦持久化层)

### 第零步：深入理解当前数据结构与持久化层 (重要前提)

在开始任何修改之前，请先彻底分析当前项目中：

1. **核心数据实体与内存表示**:
    * 识别项目中核心的数据实体，特别是构成“向量表”或类似表格的行数据在内存中的C++数据结构（例如，`QList<QStringList>`, `std::vector<CustomRowObject>`, 或其他自定义容器和对象）。
    * 分析每一行数据包含哪些类型的列，以及这些类型在内存中是如何表示的。
2. **元数据与配置数据内存表示**:
    * 找出项目中用于定义管脚、时序集、用户配置等的全局性数据在内存中的表示方式。
3. **当前持久化接口与实现**:
    * **定位数据访问对象 (DAO) 或数据处理模块**: 找到负责将内存中的数据结构（上述1和2）与 SQLite 数据库进行交互（读取/写入）的类或函数集。这些是本次重构的**核心目标区域**。
    * 分析这些模块是如何执行 SQL 语句、管理数据库连接、处理事务以及映射数据库表到内存对象的。
    * 特别关注大量行数据是如何通过这些接口写入 SQLite 表，以及如何从 SQLite 表加载到内存数据结构的。
4. **数据流与持久化层边界**:
    * 清晰界定业务逻辑层/UI层调用持久化层接口的边界。例如，当用户点击“保存”时，UI层可能会调用一个类似 `ProjectManager::saveProject()` 的方法，该方法进而调用数据处理模块的 `saveVectorData(...)` 等。我们的目标是重写 `saveVectorData(...)` 的内部实现，而不改变其签名或行为契约。

### 第一步：调整 SQLite 数据库 Schema (通过持久化层初始化逻辑)

1. **创建新的“向量表主记录表” (Vector Table Master Record Table)**:
    * 在负责初始化数据库 Schema 的代码中（通常在创建新项目或首次打开数据库时执行），添加逻辑以创建此新表。
    * **建议字段**:
        * `id` (INTEGER, PRIMARY KEY, AUTOINCREMENT)
        * `table_name` (TEXT, NOT NULL, UNIQUE)
        * `binary_data_filename` (TEXT, NOT NULL)
        * `schema_version` (INTEGER, NOT NULL, DEFAULT 1)
        * `row_count` (INTEGER, NOT NULL, DEFAULT 0)
        * `column_count` (INTEGER, NOT NULL, DEFAULT 0)
        * `created_at` (DATETIME, DEFAULT CURRENT_TIMESTAMP)
        * `updated_at` (DATETIME, DEFAULT CURRENT_TIMESTAMP)
    * **请分析现有 schema 创建逻辑 (通常通过执行 `.sql` 脚本或代码直接创建表) 并进行扩展。**

2. **调整/确认“向量表列配置表” (Vector Table Column Configuration Table)**:
    * 确保此表（或类似功能的表）的 schema 定义能够满足描述二进制文件列结构的需求。其创建和管理也应通过持久化层的初始化逻辑。
    * **建议字段**:
        * `id` (INTEGER, PRIMARY KEY, AUTOINCREMENT)
        * `vector_table_id` (INTEGER, NOT NULL): 外键，关联到上述“向量表主记录表”的 `id`。
        * `column_name` (TEXT, NOT NULL)
        * `column_order` (INTEGER, NOT NULL)
        * `column_type` (TEXT): 用于指导二进制序列化/反序列化。
        * `data_properties` (TEXT, 可选)
    * 此表的任何修改也应通过持久化层的 schema 管理逻辑进行。

3. **关于原有大量行数据存储表**:
    * 定位当前 SQLite schema 中用于存储大量“向量行数据”的表。
    * **策略**: 在新的持久化逻辑中，将不再向此表写入大量的行数据。读取旧项目时，可能需要一次性迁移（如果支持旧格式打开并自动转换为新格式）。新创建的项目将直接使用新方案。
    * **目标**: 持久化层在处理行数据时，将绕过对此旧表的写入。

### 第二步：设计二进制文件格式 (`.vbindata` 文件) - 作为持久化层内部细节

此设计对上层业务逻辑透明。

1. **文件命名与位置管理**:
    * 由持久化层内部逻辑根据 `.db` 中存储的 `binary_data_filename` 字段来确定和管理。
    * 路径解析应在持久化层内部完成。

2. **文件头部 (Header) - 推荐**:
    * 持久化层在创建或写入二进制文件时，负责维护此头部。
    * **建议包含**:
        * `magic_number`
        * `file_format_version`
        * `data_schema_version` (与 `.db` 中对应表的 `schema_version` 同步)
        * `row_count_in_file`
        * `column_count_in_file`
        * `timestamp_created`, `timestamp_updated`
        * (可选) `compression_type`, `reserved_bytes`

3. **行数据记录 (Records)**:
    * 持久化层负责将内存中的行数据对象，按照“向量表列配置表”定义的结构，序列化为二进制记录。
    * **序列化策略 (由持久化层实现)**:
        * **数据类型映射**: 定义从内存对象属性到二进制类型的映射规则。
        * **记录结构**: 选择固定大小或可变大小记录，并实现相应的序列化/反序列化逻辑。
        * **字节序**: 统一处理。

4. **（可选）数据压缩**:
    * 如果启用，压缩和解压操作应封装在持久化层内部。

### 第三步：重构持久化层核心逻辑

这是本次任务的核心。请分析并重构项目中负责向量表数据加载、保存的核心持久化模块/类。

1. **内存数据模型接口不变**:
    * 持久化层加载数据后，返回给业务逻辑层的内存数据结构类型不应改变。
    * 持久化层接收来自业务逻辑层的待保存数据时，其数据结构类型也不应改变。

2. **数据加载逻辑 (供上层调用的接口内部实现变更)**:
    * 当上层（例如项目打开逻辑）请求加载特定向量表数据时，持久化层执行：
        * **内部查询 `.db`**: 获取该向量表的元数据 (`binary_data_filename`, `schema_version`, 列配置等)。
        * **内部读取二进制文件**:
            * 找到并打开 `binary_data_filename` 对应的文件。
            * 读取并校验文件头。进行版本兼容性检查与数据适配（见第七步）。
            * 根据列配置和文件版本，从二进制文件中逐行读取数据，反序列化到**与之前相同的内存数据结构中**。
        * 将填充好的内存数据结构返回给调用者。

3. **数据保存逻辑 (供上层调用的接口内部实现变更)**:
    * 当上层请求保存特定向量表数据时，持久化层接收与之前相同的内存数据结构。
    * **内部序列化**: 根据 `.db` 中该向量表的列配置，将内存中的每一行数据序列化为字节流。
    * **内部写入二进制文件**:
        * 按推荐策略（完整覆盖写入）到对应的二进制文件。
        * 更新文件头。
    * **内部更新 `.db`**: 更新“向量表主记录表”中该向量表的 `row_count` 和 `updated_at`。
    * **移除原先在该接口实现中，将大量行数据写入 SQLite 表的逻辑。**

4. **行数据操作的持久化 (如果存在细粒度接口)**:
    * 如果持久化层提供了例如 `addRow(rowData)`, `deleteRow(rowIndex)`, `updateRow(rowIndex, rowData)` 这样的接口，它们的内部实现也需要改变。
    * 由于推荐的二进制写入策略是“整体覆盖”，这些细粒度操作在修改内存模型后，可能不会立即触发IO。真正的持久化会延迟到整体“保存项目”操作时。
    * 或者，如果需要更即时的持久化（有风险且可能影响性能），则这些接口的内部实现需要：修改内存模型 -> 重新序列化整个表数据 -> 重写整个二进制文件 -> 更新DB元数据。**保持接口签名不变是关键。**

### 第四步：调整项目管理流程中的持久化调用点

确保在项目“新建”、“打开”、“保存”等流程中，调用持久化层接口的方式和时机与之前一致，只是这些接口的内部实现已按新方案重构。

1. **新建项目时的持久化**:
    * 持久化层初始化 `.db` (包含新表)。
    * 当“创建向量表”的业务逻辑完成后，它会调用持久化层的接口来记录这个新表。持久化层内部会在 `.db` 中创建主记录，并创建空的二进制文件。
    * 当“配置列”完成后，业务逻辑调用持久化层接口更新元数据，持久化层内部更新 `.db` 中的列配置。
    * 当“录入初始行数据”后，业务逻辑将这些行数据（以现有内存格式）传递给持久化层接口进行保存，持久化层内部将其写入二进制文件并更新 `.db` 元数据。

2. **打开项目时的持久化**:
    * 业务逻辑调用持久化层接口加载项目。持久化层内部按“第三步 - 数据加载逻辑”执行。

3. **保存项目时的持久化**:
    * 业务逻辑调用持久化层接口保存项目。持久化层内部按“第三步 - 数据保存逻辑”执行。

### 第五步：实现二进制数据序列化与反序列化模块 (作为持久化层内部组件)

1. **封装性**: 这些功能应作为持久化层内部的私有辅助类或静态方法。
2. **接口**:
    * `serializeRow(const MemoryRowObject& row, const ColumnSchema& schema) -> QByteArray`
    * `deserializeRow(const QByteArray& bytes, const ColumnSchema& schema, int fileVersion) -> MemoryRowObject`
    * `readBinaryHeader(QIODevice* device) -> BinaryHeaderObject`
    * `writeBinaryHeader(QIODevice* device, const BinaryHeaderObject& header)`
3. **专注于将程序现有内存中的行数据结构与二进制字节流进行相互转换。**

### 第六步：文件路径和管理的内部处理

由持久化层负责解析和管理二进制文件的相对/绝对路径，对上层透明。

### 第七步：格式演进与版本兼容性 (持久化层内部逻辑)

1. **版本比较**: 持久化层在加载二进制数据时，内部比较 `.db` 中的 `schema_version` 和二进制文件头中的 `data_schema_version`。
2. **适配逻辑**: 如果版本不匹配，持久化层内部调用特定版本的反序列化逻辑，并在将数据转换为当前业务逻辑层期望的内存结构时，进行必要的适配（填充默认值、忽略废弃数据等）。
3. **升级写入**: 当保存时，持久化层总是以最新的 `schema_version` 格式写入二进制数据，并更新文件头中的版本号。

## 3. 核心注意事项 (对持久化层开发者)

* **接口稳定性**: 持久化层暴露给业务逻辑层的公共接口（函数签名、参数类型、返回值类型）**绝对不能改变**。
* **数据一致性**: 确保 `.db` 中的元数据（特别是 `row_count` 和 `schema_version`）与二进制文件的实际内容和头部信息保持严格同步。建议在事务中更新 `.db`。
* **错误处理**: 持久化层需要处理所有与文件IO、序列化/反序列化、数据库操作相关的潜在错误，并以符合现有错误处理机制的方式向上层报告（例如，通过返回值、异常，但最好不改变现有接口的异常抛出行为）。
* **性能透明性**: 虽然目标是提升性能，但任何由于新方案引入的显著性能下降（在非预期操作中）都需关注。

---

**引导性说明：**

在开始具体的代码修改之前，请您务必先**深入分析当前项目的代码**，特别是：

1. **数据结构**：准确理解项目中用于表示和存储“向量行数据”、“管脚配置”、“时序集配置”以及其他相关元数据的主要C++数据结构（类、结构体、容器等），这些是您在持久化层需要处理的对象。
2. **数据持久化模块/接口**：定位当前项目中负责将这些数据结构保存到 SQLite 数据库以及从数据库加载数据的**确切类和方法**。这些是您需要重构其**内部实现**的核心区域。识别出这些接口的签名和它们与业务逻辑层之间的契约。
3. **项目生命周期与持久化调用点**：分析“新建项目”、“打开项目”、“保存项目”等关键工作流程中，上层业务逻辑是在何时、以及如何调用这些持久化接口的。

在充分理解现有实现，特别是**持久化层的边界和接口**之后，再以上述方案为指导，逐步进行重构。您的工作核心是替换持久化层原有的 SQLite 行数据读写逻辑为新的二进制文件读写逻辑，同时确保对调用该持久化层的其他所有模块完全透明。
