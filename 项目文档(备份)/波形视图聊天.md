# 添加波形图视图实现
_Exported on 2025/6/12 at GMT+8 16:58:30 from Cursor (1.0.0)_

---

**User**

请你帮我分析如图红框的波形视图，并猜测如果用QT5  cmake应该如何什么实现这个效果

---

**Cursor**

好的，我们来分析一下这个截图并探讨如何使用 Qt5 和 CMake 实现这个功能。

### 1. 需求分析

您截图中的红色高亮部分是一个**波形视图（Waveform View）**，它通常用于数字信号的可视化。根据界面分析，这个视图有以下几个特点：

*   **多通道显示**：左侧的"管脚"列表（SCL, SDA）对应了波形图中的两个通道。每个通道显示一条独立的数字波形。
*   **时间轴 (X轴)**：横轴代表时间或时钟周期，从 1 开始递增。
*   **状态 (Y轴)**：纵轴代表数字信号的电平状态，即高电平（1）和低电平（0）。
*   **数据来源**：波形图的数据很可能来源于上方的"向量运行表"。表中的 `SCL` 和 `SDA` 列的 0/1 值序列，与下方波形图的起伏完全对应。
*   **交互性**：这类视图通常支持缩放（Zoom）和拖拽（Pan）来查看长序列的波形细节。

### 2. 技术选型与实现方案

在 Qt5 环境中，从头开始使用 `QPainter` 来绘制这样一个复杂的、可交互的视图工作量巨大且容易出问题。最高效、最专业的做法是使用一个第三方绘图库。

**核心推荐：QCustomPlot**

`QCustomPlot` 是一个专门为 Qt 设计的高质量、支持实时可视化、性能优异的绘图库。它非常适合用来实现您图中的效果。我注意到您的项目目录中已经包含了 `qcustomplot` 的源码（`common/qcustomplot`），这说明项目**已经集成了这个库**，这非常好，我们可以直接利用它。

### 3. 基于 QCustomPlot 的实现步骤

使用 `QCustomPlot` 实现这个波形图，主要涉及以下几个关键步骤：

#### 第一步：在UI中集成 QCustomPlot

1.  在 Qt Designer 中，拖入一个 `QWidget` 控件到您的主窗口或相应的容器中。
2.  右键点击这个 `QWidget`，选择 "Promote to..." (提升为...)。
3.  在弹出的对话框中，设置 "Promoted class name" 为 `QCustomPlot`，"Header file" 为 `qcustomplot.h`。
4.  点击 "Add" 和 "Promote"。这样，这个 `QWidget` 在运行时就会被创建为一个 `QCustomPlot` 实例。

#### 第二步：在 C++ 代码中绘制波形

假设您已经将 `QCustomPlot` 控件命名为 `customPlot`。

1.  **添加图形通道 (Graph)**：每个信号（如 SCL, SDA）在 `QCustomPlot` 中都表现为一个 `QCPGraph` 对象。

    ```cpp
    // 为 SCL 和 SDA 分别创建 graph
    QCPGraph *sclGraph = ui->customPlot->addGraph();
    QCPGraph *sdaGraph = ui->customPlot->addGraph(ui->customPlot->xAxis, ui->customPlot->yAxis2); // 可以使用不同的Y轴
    ```

2.  **设置阶梯线型**：数字波形的特点是瞬时跳变，在 `QCustomPlot` 中，这可以通过设置 `LineStyle` 为 `lsStepCenter` 来完美实现，它会在数据点的中心位置进行阶跃。

    ```cpp
    sclGraph->setLineStyle(QCPGraph::lsStepCenter);
    sdaGraph->setLineStyle(QCPGraph::lsStepCenter);

    // 也可以设置线条颜色和粗细
    sclGraph->setPen(QPen(Qt::blue)); 
    sdaGraph->setPen(QPen(Qt::red));
    ```

3.  **准备数据**：从您的数据模型（如“向量运行表”）中读取数据，并存入 `QVector<double>`。

    ```cpp
    QVector<double> timeData, sclData, sdaData;
    
    // 伪代码：遍历您的数据表
    // for (int i = 0; i < tableRowCount; ++i) {
    //     timeData.append(i + 1); // X轴：周期
    //     sclData.append(getSclValueAt(i)); // Y轴：SCL的0或1
    //     sdaData.append(getSdaValueAt(i)); // Y轴：SDA的0或1
    // }

    // 为了让SDA显示在SCL下方，可以给它的Y值加上一个固定的偏移量
    // 并且需要自定义Y轴的刻度标签
    for (int i = 0; i < tableRowCount; ++i) {
        timeData.append(i + 1); 
        sclData.append(getSclValueAt(i) + 1.5); // 绘制在 Y=1.5 和 Y=2.5 附近
        sdaData.append(getSdaValueAt(i));      // 绘制在 Y=0 和 Y=1 附近
    }
    ```

4.  **设置数据到 Graph**：

    ```cpp
    sclGraph->setData(timeData, sclData);
    sdaGraph->setData(timeData, sdaData);
    ```

5.  **配置坐标轴 (Axis)**：
    *   **X轴 (时间轴)**：设置范围和标签。

        ```cpp
        ui->customPlot->xAxis->setLabel("Cycles");
        ui->customPlot->xAxis->setRange(0, timeData.size() + 1);
        ```
    *   **Y轴 (通道轴)**：这是实现您图中效果的关键。我们需要用通道名（"SCL", "SDA"）代替数字刻度。这可以通过 `QCPAxisTickerText` 实现。

        ```cpp
        // 创建一个自定义的 Ticker
        QSharedPointer<QCPAxisTickerText> textTicker(new QCPAxisTickerText);
        textTicker->addTick(0.5, "SDA"); // 在 Y=0.5 位置显示 "SDA"
        textTicker->addTick(2.0, "SCL"); // 在 Y=2.0 位置显示 "SCL"
        
        ui->customPlot->yAxis->setTicker(textTicker);
        ui->customPlot->yAxis->setSubTicks(false); // 不显示子刻度
        ui->customPlot->yAxis->setRange(-0.5, 3.0); // 设置合适的Y轴范围
        ```

6.  **启用交互和重绘**：

    ```cpp
    // 允许用户用鼠标拖拽和滚轮缩放
    ui->customPlot->setInteractions(QCP::iRangeDrag | QCP::iRangeZoom);
    
    // 应用所有更改，重绘波形图
    ui->customPlot->replot();
    ```

#### 第三步：CMake 配置

由于您的项目已经集成了 `QCustomPlot`，`CMakeLists.txt` 中应该已经包含了必要的配置。通常需要确保：
1.  `qcustomplot.cpp` 和 `qcustomplot.h` 被添加到了 `add_executable` 或 `add_library` 的文件列表中。
2.  项目链接了 Qt5 的 `Widgets` 和 `PrintSupport` 模块（`QCustomPlot` 需要）。

```cmake
# 在 CMakeLists.txt 中确保有类似这样的配置
find_package(Qt5 COMPONENTS Widgets PrintSupport REQUIRED)

add_executable(VecEdit
    # ... 其他源文件
    common/qcustomplot.cpp
)

target_link_libraries(VecEdit PRIVATE Qt5::Widgets Qt5::PrintSupport)
```

### 总结

总而言之，您截图中的波形视图是一个非常适合用 `QCustomPlot` 库来实现的功能。您的项目已经具备了基础，只需按照上述步骤，在您的UI中添加一个 `QCustomPlot` 控件，并通过C++代码将数据表中的模型数据转换为绘图数据，配置好坐标轴和线型样式，即可高效地实现完全相同的视觉效果和交互功能。

如果您需要，我可以帮您在代码中定位具体的文件，并开始编写实现这个功能的代码。

```cpp
    // 为 SCL 和 SDA 分别创建 graph
    QCPGraph *sclGraph = ui->customPlot->addGraph();
    QCPGraph *sdaGraph = ui->customPlot->addGraph(ui->customPlot->xAxis, ui->customPlot->yAxis2); // 可以使用不同的Y轴
```

```cpp
    sclGraph->setLineStyle(QCPGraph::lsStepCenter);
    sdaGraph->setLineStyle(QCPGraph::lsStepCenter);

    // 也可以设置线条颜色和粗细
    sclGraph->setPen(QPen(Qt::blue)); 
    sdaGraph->setPen(QPen(Qt::red));
```

```cpp
    QVector<double> timeData, sclData, sdaData;
    
    // 伪代码：遍历您的数据表
    // for (int i = 0; i < tableRowCount; ++i) {
    //     timeData.append(i + 1); // X轴：周期
    //     sclData.append(getSclValueAt(i)); // Y轴：SCL的0或1
    //     sdaData.append(getSdaValueAt(i)); // Y轴：SDA的0或1
    // }

    // 为了让SDA显示在SCL下方，可以给它的Y值加上一个固定的偏移量
    // 并且需要自定义Y轴的刻度标签
    for (int i = 0; i < tableRowCount; ++i) {
        timeData.append(i + 1); 
        sclData.append(getSclValueAt(i) + 1.5); // 绘制在 Y=1.5 和 Y=2.5 附近
        sdaData.append(getSdaValueAt(i));      // 绘制在 Y=0 和 Y=1 附近
    }
```

```cpp
    sclGraph->setData(timeData, sclData);
    sdaGraph->setData(timeData, sdaData);
```

```cpp
        ui->customPlot->xAxis->setLabel("Cycles");
        ui->customPlot->xAxis->setRange(0, timeData.size() + 1);
```

```cpp
        // 创建一个自定义的 Ticker
        QSharedPointer<QCPAxisTickerText> textTicker(new QCPAxisTickerText);
        textTicker->addTick(0.5, "SDA"); // 在 Y=0.5 位置显示 "SDA"
        textTicker->addTick(2.0, "SCL"); // 在 Y=2.0 位置显示 "SCL"
        
        ui->customPlot->yAxis->setTicker(textTicker);
        ui->customPlot->yAxis->setSubTicks(false); // 不显示子刻度
        ui->customPlot->yAxis->setRange(-0.5, 3.0); // 设置合适的Y轴范围
```

```cpp
    // 允许用户用鼠标拖拽和滚轮缩放
    ui->customPlot->setInteractions(QCP::iRangeDrag | QCP::iRangeZoom);
    
    // 应用所有更改，重绘波形图
    ui->customPlot->replot();
```

```cmake
# 在 CMakeLists.txt 中确保有类似这样的配置
find_package(Qt5 COMPONENTS Widgets PrintSupport REQUIRED)

add_executable(VecEdit
    # ... 其他源文件
    common/qcustomplot.cpp
)

target_link_libraries(VecEdit PRIVATE Qt5::Widgets Qt5::PrintSupport)
```

---

**User**

我在给你这个波形视图的具体截图，你看下他的坐标轴和线型样式是怎么形成的

---

**Cursor**

好的，感谢您提供更清晰的截图。这张图让我能更精确地分析其特征。

我们来仔细看一下坐标轴和线型的实现细节：

### 1. 线型样式 (Line Style)

这是一个非常关键的细节。请注意观察信号**跳变（transition）**的位置：

*   在时间点 `2`，`SCL` 信号从低电平变为高电平。
*   在时间点 `4`，`SCL` 信号从高电平变为低电平。
*   在时间点 `6`，`SDA` 信号从高电平变为低电平。

信号的**垂直跳变部分，总是精确地落在整数刻度线上**。

在 `QCustomPlot` 中，这种绘图风格被称为 **`QCPGraph::lsStepLeft`**。

*   `lsStepLeft` 的含义是：一个数据点 `(x, y)` 定义了从位置 `x` 开始，向右延伸到下一个数据点 `x_next` 的这条水平线段的高度为 `y`。这完美符合您图中的表现。
*   (我上次提到的 `lsStepCenter` 会在两个整数刻度中间，即 `1.5`, `2.5` 的位置跳变，`lsStepRight` 会在整数刻度后立即跳变，这两种都不符合当前截图)。

**所以，正确的线型设置是 `lsStepLeft`。**

```cpp
graph->setLineStyle(QCPGraph::lsStepLeft);
```

### 2. 坐标轴 (Axes)

#### X轴 (顶部时间轴)

*   **位置**: 时间刻度 `1, 2, 3...` 显示在**图表的顶部**，而不是常规的底部。
*   **实现**: `QCustomPlot` 默认有两根X轴：`xAxis` (底部) 和 `xAxis2` (顶部)。要实现这个效果，您可以：
    1.  让顶部的 `xAxis2` 可见。
    2.  将数据和范围设置给主 `xAxis`。
    3.  将 `xAxis` 的刻度标签设置成不可见 (`ui->customPlot->xAxis->setTickLabels(false);`)。
    4.  将 `xAxis2` 的范围与 `xAxis` 关联起来，让它同步变化。

#### Y轴 (左侧通道标签)

*   **样式**: Y轴没有显示 `0, 1, 2...` 这样的数字，而是直接显示了通道的名称 `SCL` 和 `SDA`。这是一种**分类轴 (Categorical Axis)**。
*   **实现**: 我上次的分析是正确的，这需要使用 `QCPAxisTickerText`。您需要为每个通道的Y轴位置（例如，SDA的中心在Y=1，SCL的中心在Y=2）设置一个文本标签。

    ```cpp
    // 伪代码
    QSharedPointer<QCPAxisTickerText> channelTicker(new QCPAxisTickerText);
    channelTicker->addTick(1.0, "SDA"); // 在Y=1.0的位置显示 "SDA"
    channelTicker->addTick(2.0, "SCL"); // 在Y=2.0的位置显示 "SCL"
    ui->customPlot->yAxis->setTicker(channelTicker);
    ```

### 3. 网格线 (Grid)

*   **垂直网格**:
    *   在每个整数刻度 (`1, 2, 3...`) 上，是一条**实线**主网格。
    *   在两个整数刻度中间 (`1.5, 2.5, 3.5...`)，是一条**虚线（或点线）**子网格。
*   **水平网格**:
    *   在每个通道的“泳道”中间，有一条**虚线**网格，用于视觉对齐。

*   **实现**:
    *   启用主网格和子网格：`xAxis->grid()->setSubGridVisible(true)`。
    *   分别设置主网格和子网格的画笔样式（实线 `Qt::SolidLine` 和点线 `Qt::DotLine`）。

### 总结与代码实现要点

结合以上分析，一个更精确的 `QCustomPlot` 实现思路如下：

1.  **创建 Graph**: 为 SCL 和 SDA 创建两个 `QCPGraph`。
2.  **设置线型**: 将它们的 `lineStyle` 都设置为 `QCPGraph::lsStepLeft`。
3.  **准备数据**:
    *   为SCL和SDA的Y值设置不同的**基线**，以将它们分在不同的“泳道”中。例如，SDA数据在 `1.0 ± 0.4` 范围内绘制，SCL数据在 `2.0 ± 0.4` 范围内绘制。
    *   **一个重要的技巧**: 为了让 `lsStepLeft` 能完整画出最后一个数据点对应的线段，您的数据点数量需要比向量行数多一个。如果向量表有 `N` 行，您需要提供 `N+1` 个数据点，其中第 `N+1` 个点的时间戳为 `N+1`，其Y值与第 `N` 个点相同。
4.  **配置Y轴**: 使用 `QCPAxisTickerText` 将Y轴刻度替换为 "SDA", "SCL" 标签。
5.  **配置X轴**: 启用 `xAxis2` (顶部轴) 来显示时间刻度，并隐藏 `xAxis` (底部轴) 的标签。
6.  **配置网格**: 设置X轴的主网格为实线，子网格为点线。

这个分析比上次更精确，特别是 `lsStepLeft` 线型的确定，这是实现像素级匹配的关键。如果您准备好，我们可以开始着手实现这个功能。

```cpp
graph->setLineStyle(QCPGraph::lsStepLeft);
```

```cpp
    // 伪代码
    QSharedPointer<QCPAxisTickerText> channelTicker(new QCPAxisTickerText);
    channelTicker->addTick(1.0, "SDA"); // 在Y=1.0的位置显示 "SDA"
    channelTicker->addTick(2.0, "SCL"); // 在Y=2.0的位置显示 "SCL"
    ui->customPlot->yAxis->setTicker(channelTicker);
```

---

**User**

之前给你的截图是我要仿照的波形视图，现在我给你的是我现在这个项目的向量编辑器，其中有向量表以及管脚列，其中我要实现的就是管脚列（图1红框）的波形视图
请你帮我分析如果我要实现和图2一样的效果，我需要提供给你什么东西

---

**Cursor**

非常好，这个问题非常关键。将数据源（您的向量表）和目标（波形图）连接起来，是实现这个功能的核心。

为了帮您实现图2的波形效果，我需要理解您项目中几个关键部分的代码和结构。简单来说，我需要扮演一个侦探的角色，找出以下信息：

1.  **数据在哪里？**
    *   您截图中的“向量表”在Qt中是用什么控件实现的？是 `QTableWidget` 还是 `QTableView`？
    *   它的C++对象名是什么？（例如 `ui->vectorTable`）
    *   最重要的是，**如何用代码访问表格中的数据？** 特别是红框里'A'和'B'列的那些 `0` 和 `1`。是直接从控件读取，还是有一个单独的数据模型（Data Model）？

2.  **波形图画在哪里？**
    *   我们计划用来显示波形的 `QCustomPlot` 控件在哪里？它是否已经被添加到了UI中？
    *   它的C++对象名是什么？（例如 `ui->waveformPlot`）

3.  **“管脚”的定义是什么？**
    *   程序是如何知道'A'和'B'这两列是“管脚列”需要被画成波形的？这个信息是硬编码的，还是用户可以动态选择的？
    *   图2中的标签是 `SCL` 和 `SDA`，而您的表格列标题是 `A` 和 `B`。它们之间是否存在一个映射关系？（例如，A列对应SCL，B列对应SDA）。

### 我的行动计划

您不需要手动把这些信息一条条找给我。基于我们之前的讨论和您的项目结构，我可以主动去寻找这些答案。我的计划如下：

1.  **探查UI定义**：我会先寻找管理主窗口UI的文件（很可能是 `mainwindow.ui` 或 `mainwindow_setup.cpp`），来确定表格控件和（未来）波形图控件的名称。
2.  **分析数据加载逻辑**：我会查找负责向表格中填充数据的代码。这通常会暴露数据源和访问方式。根据您的项目规范，这部分逻辑可能在 `mainwindow_data_operations.cpp` 或 `mainwindow_project_tables.cpp` 中。
3.  **提出具体实现方案**：一旦我掌握了以上信息，我就可以为您提供一份完整的、可执行的实现方案，包括：
    *   在哪个文件里添加新的 `updateWaveformPlot()` 函数。
    *   `updateWaveformPlot()` 函数的具体代码，它将精确地读取您的表格数据并绘制出目标波形。
    *   在现有代码的何处调用这个新函数，以确保数据变化时波形图能自动刷新。

我现在就开始分析您的代码库以寻找这些信息。我将首先搜索与UI设置和表格数据填充相关的代码。

好的，我已经对您的代码库进行了初步分析，并且有了一些重要发现。这就像拼图一样，我们已经找到了几块关键的图片。

### 我的发现

1.  **UI 控件名称 (已找到)**:
    *   您用来显示向量数据的表格是 `QTableWidget` 类型，它的对象名是 `m_vectorTableWidget`。这在 `mainwindow.h` 和 `mainwindow_setup.cpp` 中都有明确定义。
    *   目前代码中**没有**现成的 `QCustomPlot` 控件用于波形显示。我们需要添加一个。

2.  **数据加载逻辑 (已找到)**:
    *   函数 `onVectorTableSelectionChanged()` 和 `loadVectorTable()` 是加载和刷新表格数据的关键。
    *   `m_vectorTableWidget` 中的数据是通过 `QTableWidgetItem` 直接填充的。这意味着我们可以通过遍历 `m_vectorTableWidget` 的单元格来读取 `0` 和 `1` 的值。

3.  **管脚定义 (部分找到)**:
    *   `setupVectorTablePins()` 和 `showPinSelectionDialog()` 等函数表明，管脚（哪些列是数据列）是可以配置的。
    *   `TableStyleManager::setPinColumnWidths()` 这个函数也暗示了程序可以区分“普通列”和“管脚列”。

### 综合结论

我们已经掌握了实现功能所需的最关键信息：我们知道**从哪里读数据 (`m_vectorTableWidget`)**，并且知道**数据是什么格式（`QTableWidgetItem`）**。

现在，我们可以制定一个清晰的、分步走的计划来完成这个功能。

### 实现计划

我将分步为您添加代码，实现波形图功能。

#### 第一步：在UI中添加波形视图

我们首先需要在主窗口的UI中添加一个 `QCustomPlot` 控件作为波形图的容器，并将其放置在向量表的下方。由于您的项目规则，我会把这个新功能相关的UI设置和逻辑都封装起来。

我将在 `mainwindow_setup.cpp` 中添加一个 `setupWaveformView()` 方法，并在 `MainWindow` 的构造函数中调用它。同时，我也会在 `mainwindow.h` 中添加必要的成员变量和函数声明。

我这就为您准备代码。

好的，我已经将关键信息记录下来。现在，让我们开始第一步：在UI中集成波形视图。

我将对 `app/mainwindow.h` 和 `app/mainwindow_setup.cpp` 进行修改。

**核心改动：**
1.  **`app/mainwindow.h`**:
    *   添加 `QCustomPlot` 的前置声明。
    *   在 `private` 成员变量中，添加 `QCustomPlot *m_waveformPlot;` 用于指向我们的波形图控件。
    *   添加一个新的 `QWidget *m_waveformContainer;` 作为波形图的容器，方便我们控制其显示和隐藏。
    *   添加一个 `QSplitter *m_mainSplitter;`，它将允许用户自由调整向量表和波形图之间的高度比例。
    *   声明 `setupWaveformView()` 和 `updateWaveformView()` 两个核心私有函数。

2.  **`app/mainwindow_setup.cpp`**:
    *   在 `MainWindow` 构造函数中调用新的 `setupWaveformView()`。
    *   在 `setupUI()` 中，用 `QSplitter` 替换原来的布局，将 `m_vectorTableContainer` 和新的 `m_waveformContainer` 添加进去。
    *   实现 `setupWaveformView()` 函数，在这个函数里，我们会创建 `QCustomPlot` 实例并进行基础配置，然后将其添加到 `m_waveformContainer` 中。

下面是具体的代码修改：

I will now modify `app/mainwindow.h` to add the necessary declarations for the waveform view.

好的，我来修改 `app/mainwindow.h`。

```cpp:app/mainwindow.h
// ... existing code ...
#include "../database/binaryfilehelper.h"
#include "../common/tablestylemanager.h"

// 前置声明
class VectorTableItemDelegate;
class DialogManager;
class QCustomPlot;

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
// ... existing code ...
    void validateHexInput(const QString &text);

private:
    void setupUI();
    void setupMenu();
    void setupVectorTableUI();
    void setupTabBar();
    void setupSidebarNavigator();
    void setupVectorColumnPropertiesBar();
    void setupWaveformView();
    void updateWaveformView();
    QFrame *createHorizontalSeparator(); // 创建水平分隔线的辅助函数
    void resetSidebarNavigator();
    void addVectorTableTab(int tableId, const QString &tableName);
// ... existing code ...
    QAction *m_openProjectAction;
    QAction *m_closeProjectAction;

    // 向量表显示相关的UI组件
    QSplitter *m_mainSplitter;      // 主分割器
    QTableWidget *m_vectorTableWidget;
    QComboBox *m_vectorTableSelector;
    QWidget *m_centralWidget;
    QWidget *m_welcomeWidget;
    QWidget *m_vectorTableContainer;
    QWidget *m_waveformContainer; // 波形图容器
    QCustomPlot *m_waveformPlot;      // 波形图控件
    QAction *m_fillVectorAction;
    QAction *m_fillTimeSetAction;
    QAction *m_replaceTimeSetAction;
// ... existing code ...
```

现在，我将修改 `app/mainwindow_setup.cpp` 以集成这个新的波形视图。

```cpp
// ... existing code ...
#include "../database/binaryfilehelper.h"
#include "../common/tablestylemanager.h"

// 前置声明
class VectorTableItemDelegate;
class DialogManager;
class QCustomPlot;

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
// ... existing code ...
    void validateHexInput(const QString &text);

private:
    void setupUI();
    void setupMenu();
    void setupVectorTableUI();
    void setupTabBar();
    void setupSidebarNavigator();
    void setupVectorColumnPropertiesBar();
    void setupWaveformView();
    void updateWaveformView();
    QFrame *createHorizontalSeparator(); // 创建水平分隔线的辅助函数
    void resetSidebarNavigator();
    void addVectorTableTab(int tableId, const QString &tableName);
// ... existing code ...
    QAction *m_openProjectAction;
    QAction *m_closeProjectAction;

    // 向量表显示相关的UI组件
    QSplitter *m_mainSplitter;      // 主分割器
    QTableWidget *m_vectorTableWidget;
    QComboBox *m_vectorTableSelector;
    QWidget *m_centralWidget;
    QWidget *m_welcomeWidget;
    QWidget *m_vectorTableContainer;
    QWidget *m_waveformContainer; // 波形图容器
    QCustomPlot *m_waveformPlot;      // 波形图控件
    QAction *m_fillVectorAction;
    QAction *m_fillTimeSetAction;
    QAction *m_replaceTimeSetAction;
// ... existing code ...
```

好的，我来修改 `app/mainwindow_setup.cpp`。

```cpp:app/mainwindow_setup.cpp
// ... existing code ...
#include "common/tablestylemanager.h"
#include "vector/vectortabledelegate.h"
#include "pin/pinvalueedit.h"
#include "common/qcustomplot.h"

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), m_isUpdatingUI(false), m_currentHexValueColumn(-1)
{
    setupUI();
    setupSidebarNavigator();          // 必须在 setupMenu() 之前调用，因为它初始化了 m_sidebarDock
    setupVectorColumnPropertiesBar(); // 必须在 setupMenu() 之前调用，因为它初始化了 m_columnPropertiesDock
    setupWaveformView();              // 在 setupMenu() 之前调用，因为它初始化了 m_waveformContainer
    setupMenu();

    // 创建对话框管理器
    m_dialogManager = new DialogManager(this);
// ... existing code ...
void MainWindow::setupUI()
{
    // 创建一个中央窗口小部件
    m_centralWidget = new QWidget(this);
    QVBoxLayout *mainLayout = new QVBoxLayout(m_centralWidget);

    // 创建欢迎页面
    m_welcomeWidget = new QWidget(this);
    QVBoxLayout *welcomeLayout = new QVBoxLayout(m_welcomeWidget);

    // 添加欢迎标签
    QLabel *welcomeLabel = new QLabel(tr("欢迎使用向量编辑器"), m_welcomeWidget);
    welcomeLabel->setAlignment(Qt::AlignCenter);
    welcomeLabel->setStyleSheet("font-size: 20pt; font-weight: bold; margin: 20px;");

    // 添加说明标签
    QLabel *instructionLabel = new QLabel(tr("请使用\"文件\"菜单创建或打开项目，然后通过\"查看\"菜单查看数据表"), m_welcomeWidget);
    instructionLabel->setAlignment(Qt::AlignCenter);
    instructionLabel->setStyleSheet("font-size: 14pt; margin: 10px;");

    // 将标签添加到欢迎页面布局
    welcomeLayout->addStretch();
    welcomeLayout->addWidget(welcomeLabel);
    welcomeLayout->addWidget(instructionLabel);
    welcomeLayout->addStretch();

    // 创建向量表和波形图的UI
    setupVectorTableUI();

    // 创建一个垂直分割器
    m_mainSplitter = new QSplitter(Qt::Vertical, this);
    m_mainSplitter->addWidget(m_vectorTableContainer);
    m_mainSplitter->addWidget(m_waveformContainer);
    m_mainSplitter->setStretchFactor(0, 3); // 向量表占75%
    m_mainSplitter->setStretchFactor(1, 1); // 波形图占25%

    // 初始显示欢迎页面，隐藏分割器
    mainLayout->addWidget(m_welcomeWidget);
    mainLayout->addWidget(m_mainSplitter);
    m_mainSplitter->setVisible(false);

    setCentralWidget(m_centralWidget);
}

void MainWindow::setupMenu()
{
// ... existing code ...
    m_viewMenu = menuBar()->addMenu(tr("视图(&I)"));
    QAction *toggleSidebarAction = m_sidebarDock->toggleViewAction();
    toggleSidebarAction->setText(tr("导航栏"));
    m_viewMenu->addAction(toggleSidebarAction);

    QAction *togglePropertiesAction = m_columnPropertiesDock->toggleViewAction();
    togglePropertiesAction->setText(tr("向量列属性"));
    m_viewMenu->addAction(togglePropertiesAction);

    QAction *toggleWaveformAction = new QAction(tr("波形视图"), this);
    toggleWaveformAction->setCheckable(true);
    toggleWaveformAction->setChecked(true);
    connect(toggleWaveformAction, &QAction::triggered, m_waveformContainer, &QWidget::setVisible);
    m_viewMenu->addAction(toggleWaveformAction);
}

void MainWindow::setupVectorTableUI()
{
// ... existing code ...
// ... existing code ...
void MainWindow::closeEvent(QCloseEvent *event)
{
    saveWindowState(); // 保存窗口状态
    QMainWindow::closeEvent(event);
}

void MainWindow::setupWaveformView()
{
    m_waveformContainer = new QWidget(this);
    QVBoxLayout *layout = new QVBoxLayout(m_waveformContainer);
    layout->setContentsMargins(0, 0, 0, 0);

    m_waveformPlot = new QCustomPlot(m_waveformContainer);
    layout->addWidget(m_waveformPlot);

    // --- 基本配置 ---
    m_waveformPlot->setInteractions(QCP::iRangeDrag | QCP::iRangeZoom);
    m_waveformPlot->xAxis2->setVisible(true); // 使用顶部X轴显示时间

    // 关联顶部和底部X轴的范围
    connect(m_waveformPlot->xAxis, SIGNAL(rangeChanged(QCPRange)), m_waveformPlot->xAxis2, SLOT(setRange(QCPRange)));

    // 隐藏Y轴刻度标签，我们稍后会用自定义标签
    m_waveformPlot->yAxis->setTickLabels(false);
    m_waveformPlot->yAxis->setSubTicks(false);

    // 设置网格线
    m_waveformPlot->xAxis->grid()->setSubGridVisible(true);
    m_waveformPlot->yAxis->grid()->setSubGridVisible(true);
    m_waveformPlot->xAxis->grid()->setPen(QPen(QColor(220, 220, 220), 1, Qt::SolidLine));
    m_waveformPlot->yAxis->grid()->setPen(QPen(QColor(220, 220, 220), 1, Qt::SolidLine));
    m_waveformPlot->xAxis->grid()->setSubGridPen(QPen(QColor(240, 240, 240), 1, Qt::DotLine));
    m_waveformPlot->yAxis->grid()->setSubGridPen(QPen(QColor(240, 240, 240), 1, Qt::DotLine));

    m_waveformContainer->setVisible(true); // 默认可见
}
```

我已经完成了第一步。我们成功地将 `QCustomPlot` 集成到了您的主窗口布局中，并添加了菜单项来控制其显示/隐藏。

现在，我们进入第二步，也是最核心的一步：**编写 `updateWaveformView()` 函数来真正地读取数据和绘制波形。**

我将创建一个新文件 `app/mainwindow_waveform.cpp` 来存放这个功能的实现，这符合您项目的模块化规范。

准备好了吗？好的，我准备好了。

我已经完成了第一步的修改，将 `QCustomPlot` 集成到了UI中，并添加了必要的菜单项和布局管理。

现在，我将为你创建 `app/mainwindow_waveform.cpp` 文件，并实现 `updateWaveformView()` 函数。这个函数将是整个功能的核心，负责从 `m_vectorTableWidget` 读取数据，并将其转换为波形图。

**`updateWaveformView()` 的核心逻辑**：
1.  **清除旧波形**：每次更新时，先清空 `m_waveformPlot` 中所有旧的图形。
2.  **识别管脚列**：遍历 `m_vectorTableWidget` 的列，通过列标题或一个内部标记来识别出哪些是需要绘制的管脚列（例如'A', 'B'等）。
3.  **提取数据**：对于每一个管脚列，遍历所有行，读取单元格中的 `0` 或 `1`，并将它们与行号（作为时间轴 `x`）一起存入 `QVector`。
4.  **创建并绘制Graph**：为每个管脚创建一个 `QCPGraph` 对象。
    *   设置线型为 `QCPGraph::lsStepLeft`，以匹配目标样式。
    *   将提取出的数据点设置给 `QCPGraph`。
    *   为每个 `Graph` 分配一个独特的颜色和Y轴上的“泳道”。
5.  **配置坐标轴**：
    *   **Y轴**：使用 `QCPAxisTickerText` 创建自定义刻度，用管脚名称（如 "A", "B"）作为标签。
    *   **X轴**：根据数据点的数量设置合适的范围。
6.  **重绘视图**：调用 `m_waveformPlot->replot()` 来显示更新后的波形。

我还会确保在合适的时机调用 `updateWaveformView()`，例如：
*   当加载或切换向量表时 (`onVectorTableSelectionChanged`)。
*   当表格数据被修改时 (`onTableCellChanged`)。

现在，我将创建并编写 `app/mainwindow_waveform.cpp` 文件。

```cpp
// ... existing code ...
#include "common/tablestylemanager.h"
#include "vector/vectortabledelegate.h"
#include "pin/pinvalueedit.h"
#include "common/qcustomplot.h"

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), m_isUpdatingUI(false), m_currentHexValueColumn(-1)
{
    setupUI();
    setupSidebarNavigator();          // 必须在 setupMenu() 之前调用，因为它初始化了 m_sidebarDock
    setupVectorColumnPropertiesBar(); // 必须在 setupMenu() 之前调用，因为它初始化了 m_columnPropertiesDock
    setupWaveformView();              // 在 setupMenu() 之前调用，因为它初始化了 m_waveformContainer
    setupMenu();

    // 创建对话框管理器
    m_dialogManager = new DialogManager(this);
// ... existing code ...
void MainWindow::setupUI()
{
    // 创建一个中央窗口小部件
    m_centralWidget = new QWidget(this);
    QVBoxLayout *mainLayout = new QVBoxLayout(m_centralWidget);

    // 创建欢迎页面
    m_welcomeWidget = new QWidget(this);
    QVBoxLayout *welcomeLayout = new QVBoxLayout(m_welcomeWidget);

    // 添加欢迎标签
    QLabel *welcomeLabel = new QLabel(tr("欢迎使用向量编辑器"), m_welcomeWidget);
    welcomeLabel->setAlignment(Qt::AlignCenter);
    welcomeLabel->setStyleSheet("font-size: 20pt; font-weight: bold; margin: 20px;");

    // 添加说明标签
    QLabel *instructionLabel = new QLabel(tr("请使用\"文件\"菜单创建或打开项目，然后通过\"查看\"菜单查看数据表"), m_welcomeWidget);
    instructionLabel->setAlignment(Qt::AlignCenter);
    instructionLabel->setStyleSheet("font-size: 14pt; margin: 10px;");

    // 将标签添加到欢迎页面布局
    welcomeLayout->addStretch();
    welcomeLayout->addWidget(welcomeLabel);
    welcomeLayout->addWidget(instructionLabel);
    welcomeLayout->addStretch();

    // 创建向量表和波形图的UI
    setupVectorTableUI();

    // 创建一个垂直分割器
    m_mainSplitter = new QSplitter(Qt::Vertical, this);
    m_mainSplitter->addWidget(m_vectorTableContainer);
    m_mainSplitter->addWidget(m_waveformContainer);
    m_mainSplitter->setStretchFactor(0, 3); // 向量表占75%
    m_mainSplitter->setStretchFactor(1, 1); // 波形图占25%

    // 初始显示欢迎页面，隐藏分割器
    mainLayout->addWidget(m_welcomeWidget);
    mainLayout->addWidget(m_mainSplitter);
    m_mainSplitter->setVisible(false);

    setCentralWidget(m_centralWidget);
}

void MainWindow::setupMenu()
{
// ... existing code ...
    m_viewMenu = menuBar()->addMenu(tr("视图(&I)"));
    QAction *toggleSidebarAction = m_sidebarDock->toggleViewAction();
    toggleSidebarAction->setText(tr("导航栏"));
    m_viewMenu->addAction(toggleSidebarAction);

    QAction *togglePropertiesAction = m_columnPropertiesDock->toggleViewAction();
    togglePropertiesAction->setText(tr("向量列属性"));
    m_viewMenu->addAction(togglePropertiesAction);

    QAction *toggleWaveformAction = new QAction(tr("波形视图"), this);
    toggleWaveformAction->setCheckable(true);
    toggleWaveformAction->setChecked(true);
    connect(toggleWaveformAction, &QAction::triggered, m_waveformContainer, &QWidget::setVisible);
    m_viewMenu->addAction(toggleWaveformAction);
}

void MainWindow::setupVectorTableUI()
{
// ... existing code ...
// ... existing code ...
void MainWindow::closeEvent(QCloseEvent *event)
{
    saveWindowState(); // 保存窗口状态
    QMainWindow::closeEvent(event);
}

void MainWindow::setupWaveformView()
{
    m_waveformContainer = new QWidget(this);
    QVBoxLayout *layout = new QVBoxLayout(m_waveformContainer);
    layout->setContentsMargins(0, 0, 0, 0);

    m_waveformPlot = new QCustomPlot(m_waveformContainer);
    layout->addWidget(m_waveformPlot);

    // --- 基本配置 ---
    m_waveformPlot->setInteractions(QCP::iRangeDrag | QCP::iRangeZoom);
    m_waveformPlot->xAxis2->setVisible(true); // 使用顶部X轴显示时间

    // 关联顶部和底部X轴的范围
    connect(m_waveformPlot->xAxis, SIGNAL(rangeChanged(QCPRange)), m_waveformPlot->xAxis2, SLOT(setRange(QCPRange)));

    // 隐藏Y轴刻度标签，我们稍后会用自定义标签
    m_waveformPlot->yAxis->setTickLabels(false);
    m_waveformPlot->yAxis->setSubTicks(false);

    // 设置网格线
    m_waveformPlot->xAxis->grid()->setSubGridVisible(true);
    m_waveformPlot->yAxis->grid()->setSubGridVisible(true);
    m_waveformPlot->xAxis->grid()->setPen(QPen(QColor(220, 220, 220), 1, Qt::SolidLine));
    m_waveformPlot->yAxis->grid()->setPen(QPen(QColor(220, 220, 220), 1, Qt::SolidLine));
    m_waveformPlot->xAxis->grid()->setSubGridPen(QPen(QColor(240, 240, 240), 1, Qt::DotLine));
    m_waveformPlot->yAxis->grid()->setSubGridPen(QPen(QColor(240, 240, 240), 1, Qt::DotLine));

    m_waveformContainer->setVisible(true); // 默认可见
}
```

```cpp
// ... existing code ...
#include "common/tablestylemanager.h"
#include "vector/vectortabledelegate.h"
#include "pin/pinvalueedit.h"
#include "common/qcustomplot.h"

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), m_isUpdatingUI(false), m_currentHexValueColumn(-1)
{
    setupUI();
    setupSidebarNavigator();          // 必须在 setupMenu() 之前调用，因为它初始化了 m_sidebarDock
    setupVectorColumnPropertiesBar(); // 必须在 setupMenu() 之前调用，因为它初始化了 m_columnPropertiesDock
    setupWaveformView();              // 在 setupMenu() 之前调用，因为它初始化了 m_waveformContainer
    setupMenu();

    // 创建对话框管理器
    m_dialogManager = new DialogManager(this);
// ... existing code ...
void MainWindow::setupUI()
{
    // 创建一个中央窗口小部件
    m_centralWidget = new QWidget(this);
    QVBoxLayout *mainLayout = new QVBoxLayout(m_centralWidget);

    // 创建欢迎页面
    m_welcomeWidget = new QWidget(this);
    QVBoxLayout *welcomeLayout = new QVBoxLayout(m_welcomeWidget);

    // 添加欢迎标签
    QLabel *welcomeLabel = new QLabel(tr("欢迎使用向量编辑器"), m_welcomeWidget);
    welcomeLabel->setAlignment(Qt::AlignCenter);
    welcomeLabel->setStyleSheet("font-size: 20pt; font-weight: bold; margin: 20px;");

    // 添加说明标签
    QLabel *instructionLabel = new QLabel(tr("请使用\"文件\"菜单创建或打开项目，然后通过\"查看\"菜单查看数据表"), m_welcomeWidget);
    instructionLabel->setAlignment(Qt::AlignCenter);
    instructionLabel->setStyleSheet("font-size: 14pt; margin: 10px;");

    // 将标签添加到欢迎页面布局
    welcomeLayout->addStretch();
    welcomeLayout->addWidget(welcomeLabel);
    welcomeLayout->addWidget(instructionLabel);
    welcomeLayout->addStretch();

    // 创建向量表和波形图的UI
    setupVectorTableUI();

    // 创建一个垂直分割器
    m_mainSplitter = new QSplitter(Qt::Vertical, this);
    m_mainSplitter->addWidget(m_vectorTableContainer);
    m_mainSplitter->addWidget(m_waveformContainer);
    m_mainSplitter->setStretchFactor(0, 3); // 向量表占75%
    m_mainSplitter->setStretchFactor(1, 1); // 波形图占25%

    // 初始显示欢迎页面，隐藏分割器
    mainLayout->addWidget(m_welcomeWidget);
    mainLayout->addWidget(m_mainSplitter);
    m_mainSplitter->setVisible(false);

    setCentralWidget(m_centralWidget);
}

void MainWindow::setupMenu()
{
// ... existing code ...
    m_viewMenu = menuBar()->addMenu(tr("视图(&I)"));
    QAction *toggleSidebarAction = m_sidebarDock->toggleViewAction();
    toggleSidebarAction->setText(tr("导航栏"));
    m_viewMenu->addAction(toggleSidebarAction);

    QAction *togglePropertiesAction = m_columnPropertiesDock->toggleViewAction();
    togglePropertiesAction->setText(tr("向量列属性"));
    m_viewMenu->addAction(togglePropertiesAction);

    QAction *toggleWaveformAction = new QAction(tr("波形视图"), this);
    toggleWaveformAction->setCheckable(true);
    toggleWaveformAction->setChecked(true);
    connect(toggleWaveformAction, &QAction::triggered, m_waveformContainer, &QWidget::setVisible);
    m_viewMenu->addAction(toggleWaveformAction);
}

void MainWindow::setupVectorTableUI()
{
// ... existing code ...
// ... existing code ...
void MainWindow::closeEvent(QCloseEvent *event)
{
    saveWindowState(); // 保存窗口状态
    QMainWindow::closeEvent(event);
}

void MainWindow::setupWaveformView()
{
    m_waveformContainer = new QWidget(this);
    QVBoxLayout *layout = new QVBoxLayout(m_waveformContainer);
    layout->setContentsMargins(0, 0, 0, 0);

    m_waveformPlot = new QCustomPlot(m_waveformContainer);
    layout->addWidget(m_waveformPlot);

    // --- 基本配置 ---
    m_waveformPlot->setInteractions(QCP::iRangeDrag | QCP::iRangeZoom);
    m_waveformPlot->xAxis2->setVisible(true); // 使用顶部X轴显示时间

    // 关联顶部和底部X轴的范围
    connect(m_waveformPlot->xAxis, SIGNAL(rangeChanged(QCPRange)), m_waveformPlot->xAxis2, SLOT(setRange(QCPRange)));

    // 隐藏Y轴刻度标签，我们稍后会用自定义标签
    m_waveformPlot->yAxis->setTickLabels(false);
    m_waveformPlot->yAxis->setSubTicks(false);

    // 设置网格线
    m_waveformPlot->xAxis->grid()->setSubGridVisible(true);
    m_waveformPlot->yAxis->grid()->setSubGridVisible(true);
    m_waveformPlot->xAxis->grid()->setPen(QPen(QColor(220, 220, 220), 1, Qt::SolidLine));
    m_waveformPlot->yAxis->grid()->setPen(QPen(QColor(220, 220, 220), 1, Qt::SolidLine));
    m_waveformPlot->xAxis->grid()->setSubGridPen(QPen(QColor(240, 240, 240), 1, Qt::DotLine));
    m_waveformPlot->yAxis->grid()->setSubGridPen(QPen(QColor(240, 240, 240), 1, Qt::DotLine));

    m_waveformContainer->setVisible(true); // 默认可见
}
```

好的，文件 `app/mainwindow_waveform.cpp` 不存在，我现在来创建它并添加实现代码。

```cpp:app/mainwindow_waveform.cpp
// ==========================================================
//  Headers for: mainwindow_waveform.cpp
// ==========================================================
#include "app/mainwindow.h"
#include "common/qcustomplot.h"

// Project-specific headers
#include "vector/vectordatahandler.h"
#include "common/tablestylemanager.h"

void MainWindow::updateWaveformView()
{
    if (!m_waveformPlot || !m_vectorTableWidget)
        return;

    m_waveformPlot->clearGraphs();

    // 识别需要绘制的管脚列
    QList<int> pinColumns;
    QList<QString> pinNames;
    for (int col = 0; col < m_vectorTableWidget->columnCount(); ++col)
    {
        // 假设管脚列的识别逻辑是基于列头数据或特定属性
        // 这里我们使用一个简化的逻辑：如果列不是固定的前几列，就认为是管脚列
        // 您可以根据项目的具体逻辑进行调整
        if (col >= FIXED_COLUMN_COUNT) // FIXED_COLUMN_COUNT 需要在合适的地方定义, e.g., mainwindow.h
        {
            pinColumns.append(col);
            pinNames.append(m_vectorTableWidget->horizontalHeaderItem(col)->text());
        }
    }

    if (pinColumns.isEmpty())
    {
        m_waveformPlot->replot();
        return;
    }

    const int rowCount = m_vectorTableWidget->rowCount();
    QVector<double> xData(rowCount + 1);
    for (int i = 0; i <= rowCount; ++i)
    {
        xData[i] = i; // 时间点从0到rowCount
    }

    // Y轴设置
    QSharedPointer<QCPAxisTickerText> yTicker(new QCPAxisTickerText);
    double yStep = 2.0;
    double yOffset = 1.0;

    for (int i = 0; i < pinColumns.size(); ++i)
    {
        const int col = pinColumns[i];
        const QString pinName = pinNames[i];
        const double currentYBase = yOffset + i * yStep;

        QVector<double> yData(rowCount + 1);
        for (int row = 0; row < rowCount; ++row)
        {
            QTableWidgetItem *item = m_vectorTableWidget->item(row, col);
            bool ok;
            int val = item ? item->text().toInt(&ok) : 0;
            yData[row] = currentYBase + (ok && val == 1 ? 0.5 : -0.5);
        }
        // 为了让lsStepLeft正确绘制最后一段，复制最后一个值
        if (rowCount > 0)
        {
            yData[rowCount] = yData[rowCount - 1];
        }


        QCPGraph *graph = m_waveformPlot->addGraph();
        graph->setName(pinName);
        graph->setData(xData, yData);
        graph->setLineStyle(QCPGraph::lsStepLeft);

        // 设置颜色
        QColor color = QColor::fromHsv((i * 50) % 360, 200, 255);
        graph->setPen(QPen(color));

        yTicker->addTick(currentYBase, pinName);
    }

    m_waveformPlot->yAxis->setTicker(yTicker);
    m_waveformPlot->yAxis->setRange(0, pinColumns.size() * yStep);

    m_waveformPlot->xAxis->setRange(0, rowCount > 0 ? rowCount : 10);

    m_waveformPlot->replot();
}
```

现在，我们需要将这个新文件包含到编译中，并修改 `mainwindow.h` 来定义 `FIXED_COLUMN_COUNT`。最后，在适当的位置调用 `updateWaveformView()`。

1.  **修改 `app/mainwindow.h`**：添加 `FIXED_COLUMN_COUNT` 的定义。

2.  **修改 `app/mainwindow.cpp`**：在文件末尾 `#include` 我们刚刚创建的新文件。

3.  **修改 `app/mainwindow_project_tables.cpp` (或类似文件)**：在 `onVectorTableSelectionChanged` 和 `onTableCellChanged` 等函数中调用 `updateWaveformView()`。

我将先修改 `app/mainwindow.h`。

```cpp
// ==========================================================
//  Headers for: mainwindow_waveform.cpp
// ==========================================================
#include "app/mainwindow.h"
#include "common/qcustomplot.h"

// Project-specific headers
#include "vector/vectordatahandler.h"
#include "common/tablestylemanager.h"

void MainWindow::updateWaveformView()
{
    if (!m_waveformPlot || !m_vectorTableWidget)
        return;

    m_waveformPlot->clearGraphs();

    // 识别需要绘制的管脚列
    QList<int> pinColumns;
    QList<QString> pinNames;
    for (int col = 0; col < m_vectorTableWidget->columnCount(); ++col)
    {
        // 假设管脚列的识别逻辑是基于列头数据或特定属性
        // 这里我们使用一个简化的逻辑：如果列不是固定的前几列，就认为是管脚列
        // 您可以根据项目的具体逻辑进行调整
        if (col >= FIXED_COLUMN_COUNT) // FIXED_COLUMN_COUNT 需要在合适的地方定义, e.g., mainwindow.h
        {
            pinColumns.append(col);
            pinNames.append(m_vectorTableWidget->horizontalHeaderItem(col)->text());
        }
    }

    if (pinColumns.isEmpty())
    {
        m_waveformPlot->replot();
        return;
    }

    const int rowCount = m_vectorTableWidget->rowCount();
    QVector<double> xData(rowCount + 1);
    for (int i = 0; i <= rowCount; ++i)
    {
        xData[i] = i; // 时间点从0到rowCount
    }

    // Y轴设置
    QSharedPointer<QCPAxisTickerText> yTicker(new QCPAxisTickerText);
    double yStep = 2.0;
    double yOffset = 1.0;

    for (int i = 0; i < pinColumns.size(); ++i)
    {
        const int col = pinColumns[i];
        const QString pinName = pinNames[i];
        const double currentYBase = yOffset + i * yStep;

        QVector<double> yData(rowCount + 1);
        for (int row = 0; row < rowCount; ++row)
        {
            QTableWidgetItem *item = m_vectorTableWidget->item(row, col);
            bool ok;
            int val = item ? item->text().toInt(&ok) : 0;
            yData[row] = currentYBase + (ok && val == 1 ? 0.5 : -0.5);
        }
        // 为了让lsStepLeft正确绘制最后一段，复制最后一个值
        if (rowCount > 0)
        {
            yData[rowCount] = yData[rowCount - 1];
        }


        QCPGraph *graph = m_waveformPlot->addGraph();
        graph->setName(pinName);
        graph->setData(xData, yData);
        graph->setLineStyle(QCPGraph::lsStepLeft);

        // 设置颜色
        QColor color = QColor::fromHsv((i * 50) % 360, 200, 255);
        graph->setPen(QPen(color));

        yTicker->addTick(currentYBase, pinName);
    }

    m_waveformPlot->yAxis->setTicker(yTicker);
    m_waveformPlot->yAxis->setRange(0, pinColumns.size() * yStep);

    m_waveformPlot->xAxis->setRange(0, rowCount > 0 ? rowCount : 10);

    m_waveformPlot->replot();
}
```

```cpp
// ==========================================================
//  Headers for: mainwindow_waveform.cpp
// ==========================================================
#include "app/mainwindow.h"
#include "common/qcustomplot.h"

// Project-specific headers
#include "vector/vectordatahandler.h"
#include "common/tablestylemanager.h"

void MainWindow::updateWaveformView()
{
    if (!m_waveformPlot || !m_vectorTableWidget)
        return;

    m_waveformPlot->clearGraphs();

    // 识别需要绘制的管脚列
    QList<int> pinColumns;
    QList<QString> pinNames;
    for (int col = 0; col < m_vectorTableWidget->columnCount(); ++col)
    {
        // 假设管脚列的识别逻辑是基于列头数据或特定属性
        // 这里我们使用一个简化的逻辑：如果列不是固定的前几列，就认为是管脚列
        // 您可以根据项目的具体逻辑进行调整
        if (col >= FIXED_COLUMN_COUNT) // FIXED_COLUMN_COUNT 需要在合适的地方定义, e.g., mainwindow.h
        {
            pinColumns.append(col);
            pinNames.append(m_vectorTableWidget->horizontalHeaderItem(col)->text());
        }
    }

    if (pinColumns.isEmpty())
    {
        m_waveformPlot->replot();
        return;
    }

    const int rowCount = m_vectorTableWidget->rowCount();
    QVector<double> xData(rowCount + 1);
    for (int i = 0; i <= rowCount; ++i)
    {
        xData[i] = i; // 时间点从0到rowCount
    }

    // Y轴设置
    QSharedPointer<QCPAxisTickerText> yTicker(new QCPAxisTickerText);
    double yStep = 2.0;
    double yOffset = 1.0;

    for (int i = 0; i < pinColumns.size(); ++i)
    {
        const int col = pinColumns[i];
        const QString pinName = pinNames[i];
        const double currentYBase = yOffset + i * yStep;

        QVector<double> yData(rowCount + 1);
        for (int row = 0; row < rowCount; ++row)
        {
            QTableWidgetItem *item = m_vectorTableWidget->item(row, col);
            bool ok;
            int val = item ? item->text().toInt(&ok) : 0;
            yData[row] = currentYBase + (ok && val == 1 ? 0.5 : -0.5);
        }
        // 为了让lsStepLeft正确绘制最后一段，复制最后一个值
        if (rowCount > 0)
        {
            yData[rowCount] = yData[rowCount - 1];
        }


        QCPGraph *graph = m_waveformPlot->addGraph();
        graph->setName(pinName);
        graph->setData(xData, yData);
        graph->setLineStyle(QCPGraph::lsStepLeft);

        // 设置颜色
        QColor color = QColor::fromHsv((i * 50) % 360, 200, 255);
        graph->setPen(QPen(color));

        yTicker->addTick(currentYBase, pinName);
    }

    m_waveformPlot->yAxis->setTicker(yTicker);
    m_waveformPlot->yAxis->setRange(0, pinColumns.size() * yStep);

    m_waveformPlot->xAxis->setRange(0, rowCount > 0 ? rowCount : 10);

    m_waveformPlot->replot();
}
```

好的，这是对 `app/mainwindow.h` 的修改：

```cpp:app/mainwindow.h
// ... existing code ...
#include "../database/binaryfilehelper.h"
#include "../common/tablestylemanager.h"

// 前置声明
class VectorTableItemDelegate;
class DialogManager;
class QCustomPlot;

// 定义表格中的固定列数
const int FIXED_COLUMN_COUNT = 5; // Label, Instruction, TimeSet, Capture, Ext

class MainWindow : public QMainWindow
{
    Q_OBJECT
// ... existing code ...
```

现在，我将修改 `app/mainwindow.cpp` 以包含新的 `mainwindow_waveform.cpp`。

```cpp
// ... existing code ...
#include "../database/binaryfilehelper.h"
#include "../common/tablestylemanager.h"

// 前置声明
class VectorTableItemDelegate;
class DialogManager;
class QCustomPlot;

// 定义表格中的固定列数
const int FIXED_COLUMN_COUNT = 5; // Label, Instruction, TimeSet, Capture, Ext

class MainWindow : public QMainWindow
{
    Q_OBJECT
// ... existing code ...
```

```cpp
// ... existing code ...
#include "../database/binaryfilehelper.h"
#include "../common/tablestylemanager.h"

// 前置声明
class VectorTableItemDelegate;
class DialogManager;
class QCustomPlot;

// 定义表格中的固定列数
const int FIXED_COLUMN_COUNT = 5; // Label, Instruction, TimeSet, Capture, Ext

class MainWindow : public QMainWindow
{
    Q_OBJECT
// ... existing code ...
```

```cpp
// ... existing code ...
#include "../database/binaryfilehelper.h"
#include "../common/tablestylemanager.h"

// 前置声明
class VectorTableItemDelegate;
class DialogManager;
class QCustomPlot;

// 定义表格中的固定列数
const int FIXED_COLUMN_COUNT = 5; // Label, Instruction, TimeSet, Capture, Ext

class MainWindow : public QMainWindow
{
    Q_OBJECT
// ... existing code ...
```

现在，我将修改 `app/mainwindow.cpp` 以包含新的 `mainwindow_waveform.cpp`。

好的，我来修改 `app/mainwindow.cpp`。

```cpp:app/mainwindow.cpp
// ... existing code ...
#include "mainwindow_data_operations.cpp"
#include "mainwindow_dialogs_events.cpp"
#include "mainwindow_datafix_helpers.cpp"
#include "mainwindow_vector_fill.cpp"
#include "mainwindow_waveform.cpp"
```

最后一步，我们需要在数据发生变化时调用 `updateWaveformView()`。最关键的位置是 `onVectorTableSelectionChanged()` 和 `onTableCellChanged()`。根据您的项目结构，这些函数很可能在 `mainwindow_project_tables.cpp` 或 `mainwindow_dialogs_events.cpp` 中。

我将先查找 `onVectorTableSelectionChanged` 的位置并添加调用。

```cpp
// ... existing code ...
#include "mainwindow_data_operations.cpp"
#include "mainwindow_dialogs_events.cpp"
#include "mainwindow_datafix_helpers.cpp"
#include "mainwindow_vector_fill.cpp"
#include "mainwindow_waveform.cpp"
```

好的，`onVectorTableSelectionChanged` 在 `app/mainwindow_dialogs_events.cpp` 文件中。我现在就来读取和修改它。同时，我也会修改 `onTableCellChanged` 函数，以确保在单元格数据变化时波形也能同步更新。好的，`onVectorTableSelectionChanged` 和 `onTableCellChanged` 都在 `app/mainwindow_dialogs_events.cpp` 文件中。我现在就来读取并修改它。

抱歉，刚才的工具调用出了点问题。我重新来一次。

我将读取 `app/mainwindow_dialogs_events.cpp` 文件，以便在 `onVectorTableSelectionChanged` 和 `onTableCellChanged` 函数中添加对 `updateWaveformView()` 的调用。

好的，我来修改 `app/mainwindow_dialogs_events.cpp` 文件。

```cpp:app/mainwindow_dialogs_events.cpp
// ... existing code ...
void MainWindow::onVectorTableSelectionChanged(int index)
{
    if (index < 0 || m_isUpdatingUI)
// ... existing code ...
        statusBar()->showMessage("加载向量表失败");
    }

    // 更新波形视图
    updateWaveformView();

    // 重置标志
    m_isUpdatingUI = false;
}

void MainWindow::syncTabWithComboBox(int comboBoxIndex)
{
// ... existing code ...
// ... existing code ...
// 监听单元格变更事件
void MainWindow::onTableCellChanged(int row, int column)
{
    if (m_isUpdatingUI)
    {
        return;
    }

    // 当单元格内容改变时，更新波形视图
    // 只在管脚列变化时更新，以提高效率
    if (column >= FIXED_COLUMN_COUNT)
    {
        updateWaveformView();
    }

    // 标记行为已修改状态
    onTableRowModified(row);
}

// 监听表格行已修改事件 (由 onTableCellChanged 和 onPinValueChanged 触发)
void MainWindow::onTableRowModified(int row)
// ... existing code ...
```

至此，我们已经完成了所有的编码工作！

### 总结与测试

我们一起完成了以下工作：
1.  **UI集成**：在主窗口中添加了 `QCustomPlot` 控件，并用 `QSplitter` 实现了可调整布局。
2.  **创建新模块**：按照项目规范，在新的 `app/mainwindow_waveform.cpp` 文件中实现了波形图的绘制逻辑 `updateWaveformView()`。
3.  **数据绑定**：将 `updateWaveformView()` 函数与关键事件（选择不同的向量表、修改单元格数据）绑定，实现了数据的自动刷新。
4.  **项目整合**：将新文件和常量定义正确地整合到了现有项目中。

现在，请您重新编译并运行您的项目。理论上，当您打开一个项目并加载向量表后，下方的波形视图应该会显示出来。当您切换不同的向量表，或修改管脚列（如'A', 'B'）中的 `0` 或 `1` 时，波形图应该会实时、自动地更新。

请测试一下，看看效果如何。如果遇到任何问题，随时告诉我。

```cpp
// ... existing code ...
void MainWindow::onVectorTableSelectionChanged(int index)
{
    if (index < 0 || m_isUpdatingUI)
// ... existing code ...
        statusBar()->showMessage("加载向量表失败");
    }

    // 更新波形视图
    updateWaveformView();

    // 重置标志
    m_isUpdatingUI = false;
}

void MainWindow::syncTabWithComboBox(int comboBoxIndex)
{
// ... existing code ...
// ... existing code ...
// 监听单元格变更事件
void MainWindow::onTableCellChanged(int row, int column)
{
    if (m_isUpdatingUI)
    {
        return;
    }

    // 当单元格内容改变时，更新波形视图
    // 只在管脚列变化时更新，以提高效率
    if (column >= FIXED_COLUMN_COUNT)
    {
        updateWaveformView();
    }

    // 标记行为已修改状态
    onTableRowModified(row);
}

// 监听表格行已修改事件 (由 onTableCellChanged 和 onPinValueChanged 触发)
void MainWindow::onTableRowModified(int row)
// ... existing code ...
```

```cpp
// ... existing code ...
void MainWindow::onVectorTableSelectionChanged(int index)
{
    if (index < 0 || m_isUpdatingUI)
// ... existing code ...
        statusBar()->showMessage("加载向量表失败");
    }

    // 更新波形视图
    updateWaveformView();

    // 重置标志
    m_isUpdatingUI = false;
}

void MainWindow::syncTabWithComboBox(int comboBoxIndex)
{
// ... existing code ...
// ... existing code ...
// 监听单元格变更事件
void MainWindow::onTableCellChanged(int row, int column)
{
    if (m_isUpdatingUI)
    {
        return;
    }

    // 当单元格内容改变时，更新波形视图
    // 只在管脚列变化时更新，以提高效率
    if (column >= FIXED_COLUMN_COUNT)
    {
        updateWaveformView();
    }

    // 标记行为已修改状态
    onTableRowModified(row);
}

// 监听表格行已修改事件 (由 onTableCellChanged 和 onPinValueChanged 触发)
void MainWindow::onTableRowModified(int row)
// ... existing code ...
```

---

**User**

那请你告诉我按照你的这个方案，这波形图的X轴Y轴对应我向量表中的什么

---

**Cursor**

当然，这是一个非常好的问题。根据我提供的实现方案，波形图的坐标轴与您的向量表有以下直接对应关系：

### X轴 (横轴)
*   **代表**: **向量的序号**，也就是您表格中的**行号**。
*   **对应关系**: 波形图上X坐标为 `1` 的位置，对应您向量表中**第1行**的数据。X坐标为 `2` 的位置，对应**第2行**的数据，以此类推。它直观地展示了信号随时间（即向量序列）的变化。



### Y轴 (纵轴)
*   **代表**: **不同的管脚 (Pin)**。
*   **对应关系**: Y轴本身不是一个连续的数值。图中的每一条独立的水平波形"泳道"都对应您向量表中的一个**管脚列**。
    *   Y轴上显示的标签（例如 "A"、"B"）是直接从您向量表的**列标题**中获取的。
    *   波形的高低电平，则对应了该管脚列下，每个单元格中的**值 `1` (高) 或 `0` (低)**。



### 总结
简单来说：
*   **你看波形图的左右方向，就是在看向量表的上下方向（时间/行序）。**
*   **你看波形图的上下方向，就是在看向量表的左右方向（不同管脚/列）。**

---

**User**

现在我举一个例子，我有管脚A 他的前10行单元格的值为1010101010，请你用文字图的方式帮我现在画出来，我看看你的理解是否正确

---

**Cursor**

好的，完全没问题。这个例子能很好地检验我的理解。

如果管脚A的前10行（即前10个时间单位）的值是 `1010101010`，那么根据我设计的 `lsStepLeft` 方案，它对应的波形图应该如下所示：

```text
X-轴 (向量行号):
   1   2   3   4   5   6   7   8   9   10
   |   |   |   |   |   |   |   |   |   |
A  ¯¯¯|___|¯¯¯|___|¯¯¯|___|¯¯¯|___|¯¯¯|___

(图例: ¯¯¯ 代表高电平/值'1', ___ 代表低电平/值'0', | 代表电平跳变)
```

**分步解释这个图：**

1.  **行号 1**: 值为 `1`。因此，从时间点 `1` 开始，管脚A处于**高电平** (`¯¯¯`)，并一直持续到下一个时间点。

2.  **行号 2**: 值为 `0`。因此，在时间点 `2` 的瞬间，波形发生**跳变** (`|`)，从高电平变为**低电平** (`___`)。

3.  **行号 3**: 值为 `1`。因此，在时间点 `3` 的瞬间，波形再次**跳变** (`|`)，从低电平恢复为**高电平** (`¯¯¯`)。

4.  **后续**: 这个 `高 -> 低 -> 高 -> 低` 的模式会一直重复下去，直到第10行结束。在时间点 `10`，波形从高电平跳变为低电平。

这个文字图精确地展示了 `lsStepLeft` 的行为：在每个整数时间点（行号），波形会根据该行的值**立即更新**到新的电平状态，并保持该状态直到下一个整数时间点。

所以，如果您的预期和这个图一致，那么我的理解就是正确的。

```plaintext
X-轴 (向量行号):
   1   2   3   4   5   6   7   8   9   10
   |   |   |   |   |   |   |   |   |   |
A  ¯¯¯|___|¯¯¯|___|¯¯¯|___|¯¯¯|___|¯¯¯|___

(图例: ¯¯¯ 代表高电平/值'1', ___ 代表低电平/值'0', | 代表电平跳变)
```

---

**User**

现在我再给你我要仿照的截图，重点关注管脚SCL的前六个单元格以及他对应的波形视图是怎么表示的，请你分析

---

**Cursor**

好的，这张截图非常关键，它揭示了一个比我们之前讨论的`0/1`系统更复杂的逻辑。您观察得非常仔细，SCL列的值和波形之间确实有非常特殊的对应关系。

我们来逐一分析SCL管脚前6行（也就是波形图时间点1到6）的数据：

| 向量行号 | SCL单元格的值 | 波形图中的表现 (时间点) | 分析与解读 |
| :--- | :--- | :--- | :--- |
| **1** | `X` | 1 → 2 | 一条**带交叉阴影**的波形，**维持在中间高度**。它看起来不像明确的高或低电平。 |
| **2** | `H` | 2 → 3 | 波形**跳变到高电平**，并且内部填充了**另一种不同的斜向阴影**。 |
| **3** | `L` | 3 → 4 | 波形**跳变到低电平**，内部填充与H状态相同的斜向阴影。 |
| **4** | `M` | 4 → 5 | 波形**跳变到中间高度**，内部填充与H/L状态相同的斜向阴影。 |
| **5** | `S` | 5 → 6 | 波形**跳变到高电平**，内部填充与H/L/M状态相同的斜向阴影。 |
| **6** | `V` | 6 → 7 | 波形**跳变到中间高度**，内部填充与H/L/M/S状态相同的斜向阴影。 |

### 关键结论

1.  **多状态逻辑**: 您的系统不仅仅处理 `0` (低电平) 和 `1` (高电平)。它至少定义了 `H` (High), `L` (Low), `M` (Middle/Mid-band), `X` (Don't Care/Unknown) 等多种状态。`S`和`V`似乎也代表了特定的高或中间状态。这在数字测试领域非常常见。

2.  **视觉表现多样化**:
    *   **电平高度 (Y轴)**: `H` 和 `S` 对应高电平，`L` 对应低电平，`M`、`V`、`X` 对应不同的中间电平。
    *   **填充样式 (Brush)**: 系统使用**不同的填充图案**来区分不同的信号状态或条件。`X` 状态的交叉阴影明显不同于其他状态的单斜向阴影，这可能是为了突出“不确定”或“高阻态”(High-Z) 的情况。

### 对我们实现方案的影响

这个发现**非常重要**，它意味着我们之前基于`0/1`的实现方案需要扩展。

我为您编写的 `updateWaveformView` 函数是处理 `0` 和 `1` 的良好基础，但要完美复刻您截图中的效果，我们需要进行以下升级：

1.  **扩展数据解析**:
    *   在 `updateWaveformView` 函数中，不能再简单地使用 `.toInt()` 来获取 `0` 或 `1`。
    *   我们需要一个映射关系（例如 `QMap<QChar, double>`）或者一个 `switch` 语句，来将字符 `H`, `L`, `X`, `M` 等转换成它们在Y轴上对应的具体数值 (例如, L -> -0.5, M -> 0.0, H -> 0.5)。

2.  **实现自定义填充**:
    *   波形下方的阴影效果是使用 `QCPGraph` 的 `setBrush()` 功能实现的。
    *   为了实现不同状态有不同填充图案，我们可能需要为每一种填充样式创建一个单独的 `QCPGraph`，或者在绘制时动态改变 `Brush` 的样式。更灵活的方法可能是使用 `QCPItemRect` 来在每个时间步长上手动绘制带自定义填充的矩形，但这会更复杂。

**总而言之，您的系统远比一个简单的`0/1`查看器要强大。**

要继续推进，最关键的是需要您提供**完整的状态定义**。即，您程序中所有可能的管脚值（如 `X, H, L, M, S, V` 等）分别代表什么电平以及应该对应哪种视觉样式。一旦有了这个“字典”，我就可以修改代码来实现这个高级的波形图。

---

**User**

现在我告诉你所有可能的管脚值为0,1,H,L,M,S,V,X  其中这些管脚值对应波形视图的视觉效果如图，请你结合截图帮我详细分析

---

**Cursor**

太棒了！这张图提供了我们解码视觉语言所需的全部“罗塞塔石碑”。您提供的这张包含所有状态的截图非常有价值。

结合这张新图，我可以给您一个非常详尽和准确的分析。

### 状态字典：从字符到波形

我们可以将这8个值分为三个明确的类别，每个类别都有独特的视觉语言：

---

#### 类别 1: 驱动电平 (Drive States)

这些状态代表着测试设备**主动输出**的信号。它们的视觉特征是**只有轮廓线，内部没有填充**。

| 管脚值 (Value) | 电平高度 (Level) | 视觉样式 (Style) | 详细分析 |
| :--- | :--- | :--- | :--- |
| **`0`** (行号1) | **低 (Low)** | 红色轮廓线，无填充 | 这是最基础的“驱动低电平”。波形在底部。|
| **`1`** (行号2) | **高 (High)** | 红色轮廓线，无填充 | 这是最基础的“驱动高电平”。波形在顶部。|

---

#### 类别 2: 比较电平 (Compare States)

这些状态代表测试设备**期望从被测设备上读取到**的信号。它们的视觉特征是**内部有填充图案 (Brush)**。这表示一种“采样”或“比较”的窗口期。

| 管脚值 (Value) | 电平高度 (Level) | 视觉样式 (Style) | 详细分析 |
| :--- | :--- | :--- | :--- |
| **`H`** (行号3) | **高 (High)** | **蓝色交叉阴影**填充 | “期望高电平” (Expect High)。设备在此周期内检查信号是否为高。 |
| **`L`** (行号4) | **低 (Low)** | **蓝色交叉阴影**填充 | “期望低电平” (Expect Low)。设备在此周期内检查信号是否为低。 |
| **`M`** (行号5) | **中 (Mid)** | **蓝色交叉阴影**填充 | “期望中电平” (Expect Mid-band)。设备在此周期内检查信号是否在某个中间电压范围。 |
| **`S`** (行号6) | **高 (High)** | **紫色斜向阴影**填充 | 这也是一种“期望高电平”，但使用了**不同的填充样式**。这通常代表一种不同的比较模式，例如“选通采样”(Strobe) 而不是“窗口比较”(Window Compare)。|
| **`V`** (行号7) | **中 (Mid)** | **紫色斜向阴影**填充 | “期望中电平”的另一种模式，与`S`属于同一家族。|

---

#### 类别 3: 特殊状态 (Special State)

| 管脚值 (Value) | 电平高度 (Level) | 视觉样式 (Style) | 详细分析 |
| :--- | :--- | :--- | :--- |
| **`X`** (行号8) | **中 (Mid)** | 红色轮廓线，无填充 | “高阻态”(High-Z) 或 “不关心”(Don't Care)。设备既不驱动也不比较该管脚。它的视觉特征是**无填充的中间电平线**，完美地将它与驱动状态和比较状态区分开来。|

---

### 实现方案的重大更新

这个发现意味着我们必须大幅修改 `updateWaveformView` 的渲染策略。简单的 `QCPGraph` 无法满足这种复杂的需求，因为一个 `graph` 只能有一种填充样式。

**新的实现思路：为每个管脚创建多个 Graph**

为了完美复刻这个效果，最优雅的方案是，对于**每一个管脚**（如 SCL），我们不再只创建一个 `QCPGraph`，而是创建一组 `QCPGraph`，每个 `graph` 负责一种视觉样式：

1.  **`scl_driveGraph`**:
    *   **负责状态**: `0`, `1`, `X`。
    *   **样式**: 无填充 (`setBrush(Qt::NoBrush)`)。
    *   **数据**: 当遇到 `0`, `1`, `X` 时，向这个 `graph` 添加数据点，Y值分别为 `低`、`高`、`中`。遇到其他字符时，添加一个 `NaN` (Not-a-Number) 数据点，这会让线条在此处断开。

2.  **`scl_compareGraph_A`**:
    *   **负责状态**: `H`, `L`, `M`。
    *   **样式**: 设置为**蓝色交叉阴影**的 `QBrush`。
    *   **数据**: 当遇到 `H`, `L`, `M` 时，向这个 `graph` 添加数据点，Y值分别为 `高`、`低`、`中`。遇到其他字符时，添加 `NaN`。

3.  **`scl_compareGraph_B`**:
    *   **负责状态**: `S`, `V`。
    *   **样式**: 设置为**紫色斜向阴-影**的 `QBrush`。
    *   **数据**: 当遇到 `S`, `V` 时，向这个 `graph` 添加数据点，Y值分别为 `高`、`中`。遇到其他字符时，添加 `NaN`。

通过将多种 `graph` 叠加在一起，每种 `graph` 只负责绘制自己能处理的状态，我们就可以在同一个视图中组合出您想要的丰富视觉效果。

这需要对 `updateWaveformView` 函数进行比较大的重构，但现在我们已经完全理解了目标，重构的路径也变得非常清晰了。

---

**User**

上面这些图是详细的截图请你在仔细观察各个管脚值对应的视觉效果

---

**Cursor**

您提供的这些详细截图非常棒，它们澄清了一个至关重要的细节！我的上一次分析大体上是正确的，但这些特写镜头让我看到了一个更深层次的实现方式。

我重新审视并修正我的分析：

### 最关键的发现：连续的红色线条

通过观察所有状态的边缘和过渡，我发现一个统一的规律：**那条红色的轮廓线是连续且无处不在的。**

*   无论是驱动状态(`0`, `1`)，还是比较状态(`H`, `L`, `M`, `S`, `V`)，甚至是特殊状态(`X`)，它们**都有**这条红色的轮廓线。
*   内部的填充图案（蓝色交叉、紫色斜向）看起来像是**绘制在红色线条后面的一个独立图层**。

这个发现推翻了我之前“为不同样式创建不同Graph”的想法，并指向了一个更优雅、更精确的实现模型。

---

### 修正后的状态字典

| 管脚值 | 电平高度 | 视觉分解 (Visual Breakdown) |
| :--- | :--- | :--- |
| **`0`** | **低 (Low)** | **图层1 (前景):** 红色实线<br>**图层2 (背景):** 无填充 |
| **`1`** | **高 (High)** | **图层1 (前景):** 红色实线<br>**图层2 (背景):** 无填充 |
| **`H`** | **高 (High)** | **图层1 (前景):** 红色实线<br>**图层2 (背景):** 蓝色交叉填充 |
| **`L`** | **低 (Low)** | **图层1 (前景):** 红色实线<br>**图_层2 (背景):_** 蓝色交叉填充 |
| **`M`** | **中 (Mid)** | **图层1 (前景):** 红色实线<br>**图层2 (背景):** 蓝色交叉填充 |
| **`S`** | **高 (High)** | **图层1 (前景):** 红色实线<br>**图层2 (背景):** 紫色斜向填充 |
| **`V`** | **中 (Mid)** | **图层1 (前景):** 红色实线<br>**图层2 (背景):** 紫色斜向填充 |
| **`X`** | **中 (Mid)** | **图层1 (前景):** 红色实线<br>**图层2 (背景):** 无填充 |

---

### 最优实现方案：分层绘制

为了完美实现这种前景线、背景填充分离的效果，我们需要对 `updateWaveformView` 函数采用一种**分层绘制策略**。对于每一个管脚（比如SCL），我们将创建一组图层化的`QCPGraph`：

1.  **前景层：红色信号线 (Line Graph)**
    *   这是**最顶层**的图，始终可见。
    *   **设置**:
        *   画笔 (`Pen`): 设为实心红色。
        *   填充 (`Brush`): 设为**无填充** (`Qt::NoBrush`)。
    *   **数据**: 这个Graph会包含**所有8种状态** (`0,1,H,L,M,S,V,X`) 对应的Y轴电平数据，从而形成一条连续不断的红色线条。

2.  **背景层1：蓝色比较填充 (Blue Fill Graph)**
    *   这个图层位于红色信号线**之后**。
    *   **设置**:
        *   画笔 (`Pen`): 设为**无画笔** (`Qt::NoPen`)，因为它只负责填充，不画轮廓。
        *   填充 (`Brush`): 设为蓝色、带交叉影线的 `QBrush`。
    *   **数据**: 这个Graph**只包含** `H`, `L`, `M` 状态的Y轴电平数据。当遇到其他字符时，我们会插入一个无效数据点(`NaN`)，这会在填充区域形成自然的“断开”。

3.  **背景层2：紫色比较填充 (Purple Fill Graph)**
    *   这个图层也位于红色信号线**之后**。
    *   **设置**:
        *   画笔 (`Pen`): 设为**无画笔** (`Qt::NoPen`)。
        *   填充 (`Brush`): 设为紫色、带斜向影线的 `QBrush`。
    *   **数据**: 这个Graph**只包含** `S`, `V` 状态的Y轴电平数据，遇到其他字符时同样用`NaN`断开。

**绘制顺序**: 在`QCustomPlot`中，后添加的Graph会绘制在先添加的Graph之上。所以我们的代码逻辑会是：
1. 添加 `scl_fillGraph_Purple`
2. 添加 `scl_fillGraph_Blue`
3. 添加 `scl_lineGraph` (最后添加，绘制在最顶层)

感谢您提供如此高质量的截图，这让我能够设计出可以完美复刻原生视觉效果的方案。我已经准备好按照这个更精确的模型来重构 `updateWaveformView` 函数了。

